{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Get Started See Demo <p>Doxide is a documentation generator for C++. It parses C++ source files annotated with documentation <code>/** comments */</code> or <code>/// comments</code> with additional <code>@commands</code> or arbitrary Markdown formatting. Doxide then publishes HTML documentation using MkDocs and the Material for MkDocs theme. This website is an example.</p> <p>Doxide also generates code coverage reports with sunburst charts and sortable tables, based on <code>gcov</code> data and source code parsing. These interactive reports make it easy to drill into a codebase and determine where further testing may be warranted to increase code coverage. The underlying approach improves the accuracy of code coverage results with C++, being aware of function templates that have not been instantiated, which are a blind spot of other tools.</p> <ul> <li>Doxide is configured with YAML, generates Markdown, and publishes HTML for the web.</li> <li>It aims at a modern look and feel, with responsive design for both desktop and mobile devices.</li> <li>It is written in C++ so that its primary users, C++ developers, can readily contribute.</li> <li>It is open source under an Apache 2.0 license, and runs on Linux, Mac, and Windows.</li> <li>It parses C++, with support for CUDA extensions, using Tree-sitter.</li> <li>To help with migration from other documentation tools, many standard Doxygen commands are supported.</li> </ul> <p>Development of Doxide is active, feedback is sought, and contributions very welcome. See the GitHub repository to report an issue or contribute a bug fix or feature, or contact Lawrence Murray ( ).</p> C++ InputHTML Output <pre><code>/**\n * An example.\n * \n * @tparam T Template parameter.\n * \n * @param x Input parameter.\n * @param[out] y Output parameter.\n * \n * @return Return value.\n * \n * @tip There are plenty more [demonstrations available](/demo)!\n */\ntemplate&lt;class T&gt;\nint f(int x, int&amp; y);\n</code></pre> <p>template&lt;class T&gt; int f(int x, int&amp; y)</p> <p>An example.</p> <code>T</code> Template parameter. <code>x</code> Input parameter. <code>y</code> Output parameter. Return Return value. <p>Tip</p> <p>There are plenty more demonstrations available!</p>"},{"location":"command-line/","title":"Command-line reference","text":"<p>Commands are:</p> <code>doxide init</code> Initialize configuration files. Will prompt before replacing any existing files. <code>doxide build</code> Build documentation in the output directory. <code>doxide watch</code> Watch the documentation's source files and rebuild it on changes. <code>doxide clean</code> Clean the output directory. <code>doxide cover</code> Output code coverage data to <code>stdout</code> in JSON format. <code>doxide help</code> Print usage information. <p>Command-line options are as follows. When provided, they override the same settings in the configuration file.</p> <code>--title</code> (default <code>Untitled</code>) Main page title. <code>--description</code> Main page description. <code>--output</code> (default <code>docs</code>) Output directory. <code>--coverage</code> Code coverage file (<code>.gcov</code> or <code>.json</code>)."},{"location":"configuring/","title":"Configuring Doxide","text":"<p>The <code>doxide.yaml</code> configuration file supports the following entries.</p> <code>title</code> Main page title. Overruled by command-line option <code>--title</code>. <code>description</code> Main page description. Overruled by command-line option <code>--description</code>. <code>output</code> (default <code>docs</code>) Output directory. Overruled by command-line option <code>--output</code>. <code>coverage</code> Name of a <code>.gcov</code> or <code>.json</code> file with code coverage data from which to construct a code coverage report, if desired. <code>files</code> <p>List of source files from which to extract documentation. The following wildcards are supported for pattern matching:</p> Pattern Description <code>?</code> Any single character. <code>*</code> Zero or more characters, without directory recursion. <code>**</code> Zero or more characters, with directory recursion. <code>[]</code> Any characters between the square brackets. <code>[!]</code> Any characters not between the square brackets. <code>[a-z]</code> Any characters in the range <code>a</code> to <code>z</code>. <p>For example, <code>*.hpp</code> will match all files in the root directory with a file extension of <code>.hpp</code>, while <code>**/*.hpp</code> will match all files in subdirectories, recursively, with a file extension of <code>.hpp</code>.</p> <code>groups</code> <p>List of groups used to organize documentation. Each element of the list can further contain the keys:</p> <code>name</code> Name of the group. This is used to assign entities to the group using the <code>@ingroup</code> command. <code>title</code> Title of the group, used for display purposes. <code>description</code> Description of the group, used for display purposes. <code>groups</code> Further subgroups, following the same schema. <code>defines</code> Mapping of preprocessor symbol definitions, where keys are the symbols and values are their replacements. This may be used to troubleshoot parsing issues related to the use of preprocessor macros. <p>Example</p> <pre><code>title: Example\ndescription: Example configuration file.\noutput: docs\nfiles:\n  - header.hpp\n  - \"*/*.hpp\"  # quotes may be needed when using wildcards or other special characters\n  - \"**/*.hpp\"\ncoverage: coverage.gcov\ndefines:\n  SYMBOL: value\n  DEFINED_BUT_EMPTY_SYMBOL: \"\"      \ngroups:\n  - name: top\n    title: Top-level group\n    description: Description of the top-level group.\n    groups:\n      - name: next\n        title: Next-level group\n        description: Description of the next-level group.\n  - name: another\n    title: Another top-level group.\n    description: Demonstration of another top-level group.\n</code></pre>"},{"location":"contributing/","title":"Contributing to Doxide","text":"<p>Contributions to Doxide are welcome via a pull request to the GitHub repository. Similarly, bug reports and feature suggestions can be made by opening an issue, and questions asked by starting a discussion.</p> <p>There are many ways to contribute code to Doxide. To do so you will need knowledge of C++, and may need to learn how to use Tree-sitter to parse and query C++ source files. A brief how-to on the latter is given here .</p> <p>When developing Doxide, you will need to build it from source, and rebuild it from source after making any changes. See the README.md file for instructions on working from source.</p>"},{"location":"contributing/#using-tree-sitter","title":"Using Tree-sitter","text":"<p>Tip</p> <p>You can also use the online playground.</p> <p>Install the <code>tree-sitter</code> command-line interface. This will depend on your operating system. It is widely available in Linux distributions. Once installed you may need to configure it for the first time: <pre><code>tree-sitter init-config\n</code></pre></p> <p>There may not be a C++ parser installed by default, and at any rate Doxide is written to a specific version of a specific parser. That parser can be found in the <code>contrib/tree-sitter-cuda</code> directory, which is a submodule tracking the tree-sitter-cuda CUDA parser, which is based on the tree-sitter-cpp C++ parser, which is based on the tree-sitter-c C parser. CUDA is a superset of C++ is sort-of-a-superset of C and so Doxide currently uses the CUDA parser.</p> <p>From within the <code>contrib/tree-sitter-cuda</code> directory, run, for example: <pre><code>tree-sitter parse ../../demo/parsing.hpp\n</code></pre> This will parse the given file and output the parse tree to the terminal.</p>"},{"location":"contributing/#fixing-an-issue-a-walkthrough","title":"Fixing an issue: a walkthrough","text":"<p>This is a walkthrough of fixing issue #50 reported on the Doxide GitHub repository. The issue was that Doxide would miss variables that had an array type: <pre><code>/**\n * Test member variable of array type.\n */\nint arr[10];\n</code></pre> They would not be included in the documentation, and their documentation comment would be attributed to the next entity.</p> <p>To reproduce the issue:</p> <ol> <li> <p>Add code such as the above to <code>demo/parsing.hpp</code> as a test case.</p> </li> <li> <p>From the root directory of the code repository, build the Doxide documentation and publish it with MkDocs: <pre><code>doxide build\nmkdocs serve\n</code></pre></p> </li> <li> <p>Point your browser to <code>localhost:8000</code>. This is actually the whole Doxide website that you see at doxide.org. Confirm that the bug is apparent by navigating to the Demo &gt; Parsing section. (Of course you won't see issue #50 anymore---it has been fixed!)</p> </li> </ol> <p>To fix the problem, we can start by seeing how Tree-sitter parses the code. Back in the <code>contrib/tree-sitter-cuda</code> directory, put the above code in a file called <code>test.cpp</code> and run: <pre><code>tree-sitter parse test.cpp\n</code></pre> The output is: <pre><code>(translation_unit [0, 0] - [4, 0]\n  (comment [0, 0] - [2, 3])\n  (declaration [3, 0] - [3, 12]\n    type: (primitive_type [3, 0] - [3, 3])\n    declarator: (array_declarator [3, 4] - [3, 11]\n      declarator: (identifier [3, 4] - [3, 7])\n      size: (number_literal [3, 8] - [3, 10]))))\n</code></pre></p> <p>Tip</p> <p>We could run <code>tree-sitter parse ../../demo/parsing.hpp</code> instead, but the parse tree is much larger, and it may be difficult to track down the specific problem that way.</p> <p>Now, bring up the source file src/CppParser.cpp, where Doxide's Tree-sitter queries are given as hard-coded strings in the <code>query_cpp</code> variable. These are patterns that match parse trees to select entities (e.g. types, variables, functions, macros, etc) from the source code to document. This section in particular plucks out variables and member variables: <pre><code>;; variable\n((declaration\n    declarator: [\n      (identifier) @name\n      (reference_declarator (identifier) @name)\n      (pointer_declarator (identifier) @name)\n      (init_declarator\n        declarator: [\n          (identifier) @name\n          (reference_declarator (identifier) @name)\n          (pointer_declarator (identifier) @name)\n        ]\n        value: (_) @value)\n    ]\n    default_value: (_)? @value\n  ) @variable)\n\n;; member variable\n((field_declaration\n    declarator: [\n      (field_identifier) @name\n      (reference_declarator (field_identifier) @name)\n      (pointer_declarator (field_identifier) @name)\n      (init_declarator\n        declarator: [\n          (identifier) @name\n          (field_identifier) @name\n          (reference_declarator (identifier) @name)\n          (reference_declarator (field_identifier) @name)\n          (pointer_declarator (identifier) @name)\n          (pointer_declarator (field_identifier) @name)\n        ]\n        value: (_) @value)\n    ]\n    default_value: (_)? @value\n  ) @variable)\n</code></pre></p> <p>Tip</p> <p>For more information on writing queries, see the Tree-sitter documentation for Pattern Matching with Queries.</p> <p>The query handles, among other things, <code>reference_declarator</code> and <code>pointer_declarator</code>, but we saw <code>array_declarator</code> in the parse tree above, and it does not seem to handle that. This looks like it might be the problem. So let's augment the query to handle <code>array_declarator</code>, following the same patterns as for <code>reference_declarator</code> and <code>pointer_declarator</code>: <pre><code>;; variable\n((declaration\n    declarator: [\n      (identifier) @name\n      (array_declarator (identifier) @name)\n      (reference_declarator (identifier) @name)\n      (pointer_declarator (identifier) @name)\n      (init_declarator\n        declarator: [\n          (identifier) @name\n          (array_declarator (identifier) @name)\n          (reference_declarator (identifier) @name)\n          (pointer_declarator (identifier) @name)\n        ]\n        value: (_) @value)\n    ]\n    default_value: (_)? @value\n  ) @variable)\n\n;; member variable\n((field_declaration\n    declarator: [\n      (field_identifier) @name\n      (array_declarator (field_identifier) @name)\n      (reference_declarator (field_identifier) @name)\n      (pointer_declarator (field_identifier) @name)\n      (init_declarator\n        declarator: [\n          (identifier) @name\n          (field_identifier) @name\n          (array_declarator (identifier) @name)\n          (array_declarator (field_identifier) @name)\n          (reference_declarator (identifier) @name)\n          (reference_declarator (field_identifier) @name)\n          (pointer_declarator (identifier) @name)\n          (pointer_declarator (field_identifier) @name)\n        ]\n        value: (_) @value)\n    ]\n    default_value: (_)? @value\n  ) @variable)\n</code></pre> Now rebuild and reinstall Doxide, rerun the test above (<code>doxide build</code>, <code>mkdocs serve</code>, inspect <code>localhost:8000</code>), and verify that the bug is now fixed.</p> <p>You can now commit the fix, including the test case added to <code>parsing.hpp</code> as a regression test for future, and submit a pull request on the GitHub repository.</p>"},{"location":"coverage-reports/","title":"Understanding Code Coverage Reports","text":"<p>Tip</p> <p>See the demonstration for an example code coverage report.</p> <p>Warning</p> <p>This is a new and somewhat experimental feature and behavior is subject to change. Please report problems.</p> <p>Once enabled, Doxide will include a code coverage report in the documentation. This is linked from the front page, after groups and namespaces. The report consists of three components:</p> <ol> <li>an interactive sunburst chart,</li> <li>a sortable table of source files and directories, and</li> <li>source code listings of all source files with annotated lines.</li> </ol> <p>Doxide uses source code to determine which lines are included in these code coverage reports. The approach aims to address a limitation in other tools where some source code is invisible, especially uninstantiated function templates, so that code coverage percentages are overestimated. This occurs when including lines from the compiled binary only, as some source code, such as that of uninstantiated function templates, never makes it into the compiled binary.</p> <p></p> <p>The Venn diagram above illustrates Doxide's definition of code coverage. Doxide reports the percentage of covered lines within a set of included lines as derived from source code (the area of the shaded region as a percentage of the area of the circle labeled source-derived included lines). This is different from tools that report the percentage of covered lines within a set of included lines as derived from the compiled binary (the area of the circle labeled binary-derived covered lines as a percentage of the area of the circle labeled binary-derived included lines). Doxide's approach may both include lines that are not visible in the binary (such as inline code and uninstantiated function templates), and exclude lines that are visible in the binary (usually uninteresting from the programmer's perspective).</p> <p>This is not perfect. False-inclusions and false-exclusions do occur in Doxide code coverage reports. To some extent this reflects unresolvable ambiguities in what should and should not be included, and perhaps disagreement over what constitutes code coverage. Or it could be a fixable issue (please report).</p>"},{"location":"coverage-reports/#interactive-sunburst-chart","title":"Interactive sunburst chart","text":"<p>The sunburst chart visualizes all source files according to the file hierarchy. The innermost ring represents the top level directory (or directories). Each slice represents a directory or file. Each directory slice is further divided into its subdirectories and files in the next ring out.</p> <p>The angle subtended by a slice is proportional to the number of included lines that it contains with respect to the total number of included lines at that level of the file hierarchy. For a file it is the number of included lines in the file (this is less than or equal to the total number of lines in the file). For a directory it is the number of included lines in all files and subdirectories below it (recursively). Each ring can therefore be interpreted as a pie chart at that level of the file hierarchy.</p> <p>A color and marker is assigned to each slice according to the percentage of lines covered. For a file it is the percentage of lines covered in that file. For a directory it is the percentage of lines covered in all files and subdirectories below it (recursively). The colors and markers are:</p> \u25cf\u25cf\u25cf\u25cf 90-100% of lines covered \u25cf\u25cf\u25cf\u25cb 80-90% of lines covered \u25cf\u25cf\u25cb\u25cb 70-80% of lines covered \u25cf\u25cb\u25cb\u25cb 60-70% of lines covered \u25cb\u25cb\u25cb\u25cb 0-60% of lines covered <p>Clicking on a slice selects that file or directory as the current and redraws the chart with that file or directory at the innermost ring. Clicking in the center of the chart selects the parent directory as the current and redraws the chart with that parent directory at the innermost ring. Updates are also reflected in the table beneath the chart.</p>"},{"location":"coverage-reports/#sortable-table","title":"Sortable table","text":"<p>The table below the sunburst chart gives more detailed information about the current selection. It updates with the current selection of the sunburst chart. Clicking on any of the column headings will sort the rows in ascending or descending order by that column. This allows, for example, sorting in descending order by the number of uncovered lines, which may help in targeting further tests to increase overall coverage.</p> <p>Selecting a file or directory from the table will load a new page. For a directory that page contains the same components as the original but focused on the selected directory only. For a file it brings up the source code listing of that file.</p>"},{"location":"coverage-reports/#source-code-listings","title":"Source code listings","text":"<p>When a file is selected, a new page is loaded with its full source code. All lines are numbered down the left. Line numbers are annotated with the following:</p> \u25cf 101 Line 101 is covered \u25cb 101 Line 101 is uncovered 101 Line 101 is not included <p>You may notice inaccuracies in these classifications, e.g. lines that are excluded that perhaps should not be, or lines that are included but perhaps should not be. To some extent these may represent technical limitations, but consider reporting an issue if there appears to be a consistent pattern that could be resolved.</p> <p>Info</p> <p>For further reading:</p> <ul> <li>C++ Code Coverage with Gcov, Gcovr, and Doxide for the thinking behind Doxide's code coverage support.</li> </ul>"},{"location":"coverage/","title":"Enabling Code Coverage","text":"<p>Warning</p> <p>This is a new and somewhat experimental feature and behavior is subject to change. Please report problems.</p> <p>Doxide can produce interactive code coverage reports for C++ code, including which lines have, and have not, been executed. These can be used to drill down into source files with poor coverage that may warrant additional testing.</p> <p>Doxide code coverage reports include a sunburst chart, tables sortable by column, and line-by-line annotated source code. They are constructed through a combination of source code analysis and binary program instrumentation. The combination is intended to provide more accurate coverage reports for C++ codebases, especially by accounting for uninstantiated function templates that are are blind spot for other tools, and which can produce misleading coverage results.</p> <p>The basic workflow to enable code coverage is:</p> <ol> <li>Compile code (e.g. test suite) with instrumentation for code coverage.</li> <li>Run code to collect data on which lines are executed.</li> <li>Summarize the code coverage data into a single file with command-line tools.</li> <li>Run Doxide to produce the final report.</li> </ol>"},{"location":"coverage/#compiling-for-code-coverage","title":"Compiling for Code Coverage","text":"<p>The following instructions work for both GCC and LLVM. Add the following options when compiling with <code>g++</code> or <code>clang++</code>: <pre><code>--coverage -O0 -fno-inline -fno-elide-constructors\n</code></pre> The first, <code>--coverage</code>, is the most critical. It will create a <code>.gcno</code> file alongside each object file when compiling. The other options can improve code coverage reports somewhat by ensuring that optimizations do not inline functions in such a way that will make them invisible for the purposes of code coverage.</p> <p>Tip</p> <p>To add these for a CMake project, set the <code>CXXFLAGS</code> environment variable when calling <code>cmake</code> for the first time to configure your project, e.g. <pre><code>mkdir build\ncd build\nCXXFLAGS=\"--coverage -O0 -fno-inline -fno-elide-constructors\" cmake -DCMAKE_BUILD_TYPE=Debug ..\n</code></pre> To add these for a GNU Autotools project, set the <code>CXXFLAGS</code> environment variable when calling the <code>configure</code> script to configure your project, e.g. <pre><code>./configure --prefix=$HOME/.local CXXFLAGS=\"--coverage -O0 -fno-inline -fno-elide-constructors\"\n</code></pre></p>"},{"location":"coverage/#running-for-code-coverage","title":"Running for Code Coverage","text":"<p>After compiling with the above options, simply run the program (e.g. test suite) as normal. The instrumentation will create additional <code>.gcda</code> files alongside each <code>.gcno</code> file created in the previous step. These files contain data on how many times each line of the program was executed. The data accumulates across runs, so you can run the code multiple times, perhaps in different configurations, to accumulate coverage data.</p>"},{"location":"coverage/#collating-code-coverage-data","title":"Collating Code Coverage Data","text":"<p>The next step is to collate all the <code>.gcno</code> and <code>.gcda</code> files into one file that can be ingested by Doxide. The recommended approach is to use <code>gcov</code>, which is included with GCC, or <code>llvm-cov gcov</code>, which is included with LLVM. For the former: <pre><code>find . -name '*.gcda' | xargs gcov --stdout &gt; coverage.gcov\n</code></pre> For the latter, just replace <code>gcov</code> with <code>llvm-cov gcov</code>: <pre><code>find . -name '*.gcda' | xargs llvm-cov gcov --stdout &gt; coverage.gcov\n</code></pre> Either of these commands creates a <code>coverage.gcov</code> file that can be passed to <code>doxide</code> in the next step.</p>"},{"location":"coverage/#alternatives","title":"Alternatives","text":"<p>The recommended approach is to create a <code>.gcov</code> file as above. An alternative, however, is to use JSON. The simplest way to do so is with gcovr: <pre><code>gcovr --json coverage.json\n</code></pre> This <code>coverage.json</code> file can then be used in place of the <code>coverage.gcov</code> file above. The only downside of this is that it introduces <code>gcovr</code> as an additional dependency in the workflow, which needs to be installed separately from GCC or LLVM.</p> <p>It is also possible to export JSON from <code>gcov</code> directly, but this produces one JSON file (compressed with <code>gzip</code>) for each <code>.gcda</code> input file. Further postprocessing is then needed to decompress those files and massage them into a single <code>.json</code> file, perhaps using jq.</p>"},{"location":"coverage/#reporting-coverage-data","title":"Reporting Coverage Data","text":"<p>To enable code coverage reports with Doxide, provide it with the file produced in the previous step (e.g. <code>coverage.gcov</code>) when running <code>doxide build</code>. This can be done in one of two ways:</p> <ol> <li>adding the <code>--coverage</code> command-line option, e.g.    <pre><code>doxide build --coverage coverage.gcov\n</code></pre>    or</li> <li>adding a <code>coverage</code> entry to the configuration file, e.g.    <pre><code>title: Example\ndescription: Example configuration file.\noutput: docs\nfiles:\n- \"*/**.hpp\"\n- \"*/**.cpp\"\ncoverage: coverage.gcov\n</code></pre></li> </ol> <p>The former overrides the latter, and may be more convenient if code coverage reports are not routinely produced.</p> <p>The standard <code>files</code> entry in the configuration file will be used to determine the set of files to include in the coverage report. This is the same entry as used for documentation. You may wish to add <code>.cpp</code> source files for the purposes of code coverage, which are not typically added for the purposes of documentation alone.</p>"},{"location":"coverage/#exporting-coverage-data","title":"Exporting Coverage Data","text":"<p>It is possible to export Doxide's code coverage data for further processing or use with other tools. Simply run: <pre><code>doxide cover --coverage coverage.gcov &gt; export.json\n</code></pre> The <code>--coverage</code> option may be omitted if specified in the configuration file instead. This will output JSON to <code>export.json</code>. The JSON schema is the same as that used by <code>gcovr</code>, a superset of that used by <code>gcov</code>. The data follows the definition of code coverage above. Lines that are not included by Doxide are not included in the data.</p> <p>Info</p> <p>For further reading:</p> <ul> <li>C++ Code Coverage with Gcov, Gcovr, and Doxide for the thinking behind Doxide's code coverage support.</li> <li>GCC Manual for more information on <code>.gcno</code> and <code>.gcda</code> files.</li> </ul>"},{"location":"getting-started/","title":"Initializing Doxide","text":"<p>Run, from within your source code directory: <pre><code>doxide init\n</code></pre> This will create a <code>doxide.yaml</code> configuration file, as well as some additional files for publishing with Material for MkDocs. To start, it is not necessary to modify any of these.</p> <p>Add at least <code>doxide.yaml</code> to version control, and the other files if you intend to use Material for MkDocs (highly recommended for a quick start---you can always try something else later).</p>"},{"location":"installation/","title":"Installing Doxide","text":"<p>Follow the instructions below for your operating system.</p>"},{"location":"installation/#linux","title":"Linux","text":"<p>Install from the download.indii.org software repository, following the instructions provided there. For Arch Linux and its derivatives (e.g. EndeavourOS, Garuda, Manjaro) you can find Doxide in the Arch User Repository (AUR).</p> <p>Also install MkDocs and Material for MkDocs: <pre><code>pip install mkdocs mkdocs-material\n</code></pre> See below for running MkDocs in a Python virtual environment instead.</p> <p>Tip</p> <p>Some Linux distributions include Material for MkDocs as a package too. It is typically an older version than you will get from <code>pip</code>, but it may work for you.</p>"},{"location":"installation/#mac","title":"Mac","text":"<p>Install Homebrew if not already, then: <pre><code>brew tap lawmurray/all\nbrew install doxide\n</code></pre> Also install MkDocs and Material for MkDocs: <pre><code>pip install mkdocs mkdocs-material\n</code></pre> See below for running MkDocs in a Python virtual environment instead.</p>"},{"location":"installation/#windows","title":"Windows","text":"<p>First install Doxide via your preferred means:</p> Chocolatey <p>Install Chocolatey if not already, then: <pre><code>choco install doxide\n</code></pre></p> Installer <p> Download Doxide installer</p> <p>Checksum for the download above.</p> Standalone program <p>Download the program and put it somewhere on your <code>PATH</code> environment variable, so that you can access it from a terminal.</p> <p> Download Doxide standalone program</p> <p>Checksum for the download above.</p> Windows Subsystem for Linux <p>You can use Windows Subsystem for Linux and follow the instructions for your chosen Linux distribution above.</p> <p>Then install MkDocs and Material for MkDocs. For this you will need a working Python installation; if you are using Chocolatey, a simple way is <code>choco install python</code>. Then install: <pre><code>pip install mkdocs mkdocs-material\n</code></pre> See below for running MkDocs in a Python virtual environment instead.</p>"},{"location":"installation/#install-from-source","title":"Install from source","text":"<p>If a Doxide package is not available for your operating system or you have special requirements, you can install from source. See the README.md file for instructions.</p>"},{"location":"installation/#using-a-python-virtual-environment","title":"Using a Python virtual environment","text":"<p>To manage MkDocs and other Python dependencies per-project rather than system wide, you may like to use a Python virtual environment. Create it in your project directory: <pre><code>python3 -m venv venv\n</code></pre> Then enter it: <pre><code>source venv/bin/activate\n</code></pre> You can then run  <code>pip install mkdocs mkdocs-material</code> to install MkDocs (and other dependencies) into this virtual environment, and run <code>mkdocs</code> from within that virtual environment to publish your Doxide documentation. When finished, exit the environment with: <pre><code>deactivate\n</code></pre></p>"},{"location":"organizing/","title":"Organizing Documentation","text":"<p>Doxide organizes documentation by creating a main page, and one additional page for each namespace and type, organized hierarchically. Variables, functions and operators are added to the page of the namespace or class to which they belong. Macros are added to the main page. Only entities with documentation comments are included, with the exception of namespaces, which are included as long as they are non-empty.</p> <p>Organizing by namespace is not always appropriate. An additional (or alternative) structure may be provided with groups. It is also possible to add arbitrary extra pages.</p>"},{"location":"organizing/#groups","title":"Groups","text":"<p>Groups are for organizing documentation. A hierarchy of groups can be created by adding a  <code>groups</code> section to the <code>doxide.yaml</code> configuration file. Individual entities can then be assigne to a group by using the <code>@ingroup</code> command.</p> <p>Example</p> <p>Create a group by adding the following to the <code>doxide.yaml</code> configuration file: <pre><code>groups:\n  - name: example\n    title: Example\n    description: Description of the group.\n</code></pre> Assign an entity to the group using the <code>@ingroup</code> command in its documentation comment: <pre><code>/**\n * A function.\n *\n * @ingroup example\n */\nvoid f();\n</code></pre></p> <p>The final documentation displays the entity in the group, and not on the main page, a namespace page, or elsewhere. Members of a class may not be assigned to a group (<code>@ingroup</code> is simply ignored); they are always included on the associated class page.</p> <p>If the assignment of groups leaves a namespace empty, it is removed from the final documentation. This allows organizing with groups to completely replace organizing with namespaces.</p>"},{"location":"organizing/#extra-pages","title":"Extra pages","text":"<p>Extra pages can be added to the documentation simply by adding extra Markdown files to the output directory (default: <code>docs</code>).</p> <p>Doxide distinguishes its own output files in the output directory by adding <code>generator: doxide</code> to the YAML frontmatter. When running the commands <code>doxide build</code> and <code>doxide clean</code>, it deletes or overwrites such files without prompting. It will not touch other files.</p> <p>Danger</p> <p>Clearly, you do not want to put <code>generator: doxide</code> in your extra pages, or they will be deleted!</p>"},{"location":"parsing/","title":"Parsing Considerations","text":"<p>Doxide may report parsing errors in C++ source files, even if they are building successfully with a C++ compiler. This can occur for one of two reasons:</p> <ol> <li> <p>The parser used, Tree-sitter, is different to that of a compiler, and is designed more for language tools such as syntax highlighters. It may fail to parse code that is accepted by a compiler, or even accept code that is rejected by a compiler.</p> </li> <li> <p>Doxide does not run a preprocessor before parsing (it is unclear that this would even be desirable). Consequently, it may report parsing errors in situations where C++ syntax is only valid after preprocessing, due to the use of preprocessor macros.</p> </li> </ol> <p>To demonstrate the latter case, consider the following macro definition: <pre><code>#define NO_INLINE __attribute__((noinline))\n</code></pre> This could be used in a function declaration to direct the compiler not to inline the function: <pre><code>NO_INLINE int f(int x, int y);\n</code></pre> When the preprocessor is run, the function declaration expands to the valid C++ syntax: <pre><code>__attribute__((noinline)) int f(int x, int y);\n</code></pre> But prior to running the preprocessor, this is not valid C++ syntax. For example, a parser may consider <code>NO_INLINE</code> the return type and the following <code>int</code> an error.</p> <p>When a parse error is encountered, Doxide issues a warning, and applies some error recovery logic. If that error recovery logic fails, it simply skips the problematic tokens and continues the parse. In many cases such issues are inconsequential to the final documentation and can be safely ignored, e.g. a parse error in the body of a function will produce a warning, but have no affect on its documentation.</p> <p>Doxide has both manual and automated means for resolving these issues.</p>"},{"location":"parsing/#specifying-preprocessor-symbols","title":"Specifying preprocessor symbols","text":"<p>The <code>defines</code> section of the configuration file may be used to set preprocessor symbols and their replacements---a sort of rudimentary substitute for a preprocessor. This also allows the symbols to be replaced with different values in the documentation than in the code. For example, the <code>NO_INLINE</code> example above could be resolved with the following in the configuration file: <pre><code>defines:\n  NO_INLINE: __attribute__((noinline))\n</code></pre> or, if we prefer not to include such detail in the documentation, it could be erased with: <pre><code>defines:\n  NO_INLINE: \"\"\n</code></pre></p>"},{"location":"parsing/#autocorrection","title":"Autocorrection","text":"<p>Because parse errors are usually the result of preprocessor use, Doxide has specific error recovery logic to attempt to autocorrect them. </p> <ol> <li> <p>When an error is encountered on a node in the parse tree, it steps back through the siblings of that node one by one.</p> </li> <li> <p>If it finds a sibling that looks like a preprocessor symbol, it erases that sibling and retries the parse.</p> </li> <li> <p>Otherwise, it ignores the parse error and continues.</p> </li> </ol> <p>For the purposes of step 2, following the usual convention for preprocessor symbols, a sibling looks like a preprocessor symbol if it has at least three characters consisting of uppercase letters, underscores, and digits, but starting with an uppercase letter or underscore.</p>"},{"location":"questions-and-answers/","title":"Q &amp; A","text":""},{"location":"questions-and-answers/#why-the-name","title":"Why the name?","text":"<p>The Doxygen portmanteau is worthy of a riff.</p>"},{"location":"questions-and-answers/#what-does-the-logo-represent","title":"What does the logo represent?","text":"<p>The logo is an oxygen atom from a chemistry model kit, the two holes being where you would connect it to other atoms to form a molecule (an oxide!). It is deliberately oriented to look like the face of some cute character.</p>"},{"location":"questions-and-answers/#does-doxide-support-programming-languages-other-than-c","title":"Does Doxide support programming languages other than C++?","text":"<p>Not yet, but it very possibly can. It almost certainly works for C already, although is untested in that regard, and some tweaks to the presentation may be desirable. For other programming languages, if they can be parsed with Tree-sitter, support is possible in principle, and contributions are welcome.</p>"},{"location":"questions-and-answers/#what-are-some-alternatives-to-doxide","title":"What are some alternatives to Doxide?","text":"<p>The advantages of Doxide are a modern look, YAML configuration, Markdown output, and accurate parsing of C++ with Tree-sitter. If this does not appeal, there are some other alternatives, also open source:</p> <ol> <li>Doxygen. It's an institution. Highly configurable. The downside is that the output might be considered dated.</li> <li>Doxygen Awesome, which provides a fresh look for Doxygen via an alternative style sheet.</li> <li>The combination of Doxygen + Breathe + Sphinx, which also provides a fresh look, by taking the XML output of Doxygen, converting it to reStructuredText with Breathe, then converting it to HTML with Sphinx.</li> <li>MrDox, which aims to be a replacement for Doxygen, using the clang parser.</li> </ol>"},{"location":"running/","title":"Running Doxide","text":"<p>Build the Markdown documentation with: <pre><code>doxide build\n</code></pre> This will populate the output directory (default: <code>docs</code>).</p> <p>Tip</p> <p>You may see warning messages about parse errors. These are not necessarily fatal and may not affect the documentation at all. Some relate to the use of the preprocessor and can be fixed by defining symbols in the configuration file, see Parsing Considerations.</p> <p>To publish your documentation with Material for MkDocs, use: <pre><code>mkdocs build\n</code></pre> This will populate the <code>site</code> subdirectory with HTML, CSS, and JavaScript files. This directory can be published.</p> <p>To serve the documentation locally, use: <pre><code>mkdocs serve\n</code></pre> and point your browser to the URL reported, usually <code>localhost:8000</code>.</p>"},{"location":"writing/","title":"Writing Documentation","text":"<p>Entities in C++ source code (e.g. classes, functions, operators, variables, macros) are documented by adding a documentation comment immediately before or after their declaration. Various conventions are supported to distinguish documentation comments from regular comments. The most basic is to put the comment immediately before the declaration style it as <code>/** ... */</code> rather than <code>/* ... */</code>. The contents of the documentation can be formatted with Markdown, and include various commands using the syntax <code>@command</code>.</p> <p>Example</p> <pre><code>/**\n * An example class with documentation. It might include a list:\n * \n * - first item,\n * - second item, and\n * - third item,\n *\n * or even a table:\n *\n * | Heading 1 | Heading 2 |\n * | --------- | --------- |\n * | Content 1 | Content 2 |\n */\nclass Example {\n  //\n};\n\n/**\n * An example function with documentation. This time we use commands.\n *\n * @param x First argument.\n * @param y Second argument.\n *\n * @return The result.\n */\nint f(int x, int y);\n</code></pre> <p>If the documentation is placed immediately before the declaration of an entity, the following styles are supported:</p> <ul> <li><code>/** ... */</code></li> <li><code>/*! ... */</code></li> <li><code>/// ...</code></li> <li><code>//! ...</code></li> </ul> <p>If the documentation is placed immediately after the declaration, e.g. as an end-of-line comment, the following styles are supported:</p> <ul> <li><code>/**&lt; ... */</code></li> <li><code>/*!&lt; ... */</code></li> <li><code>///&lt; ...</code></li> <li><code>//!&lt; ...</code></li> </ul> <p>Example</p> <pre><code>enum Example {\n  FIRST,   ///&lt; First possible value\n  SECOND,  ///&lt; Second possible value\n  THIRD,   ///&lt; Third possible value\n};\n</code></pre>"},{"location":"writing/#commands","title":"Commands","text":"<p>The suggestion is to use Markdown wherever possible when writing documentation comments. Doxide provides a small set of commands that can be used to organize documentation (e.g. <code>@ingroup</code>) and to ensure consistent formatting for common elements (e.g. <code>@param</code>).</p> Command Description <code>@param name</code>, <code>@param[in] name</code>, <code>@param[out] name</code>, <code>@param[in,out] name</code> Document parameter <code>name</code>. The following paragraph is the description. The additional annotations <code>[in]</code>, <code>[out]</code> and <code>[in,out]</code> mark the parameter as an input (default), output or both input and output parameter. The following paragraph is the description. <code>@tparam</code> Document a template parameter <code>name</code>. <code>@return</code> Document the return value with the following paragraph. <code>@pre</code>, <code>@post</code> Document pre- or post-conditions with the following paragraph. <code>@throw name</code> Document an exception <code>name</code> with the following paragraph. <code>@see</code> Add a paragraph of \"see also\" references. The references themselves can be formatted in Markdown, using links if desired. <code>@anchor name</code> Insert anchor that can be linked to from elsewhere with the Markdown syntax <code>[text](#name)</code>. <code>@ingroup name</code> Add the entity to the group <code>name</code>. See organizing for more information. <code>@@</code> Escape: replaced with a single <code>@</code>. <code>@/</code> Escape: replaced with a single <code>/</code>. <p>Tip</p> <p>As a particular use case, comments within documentation comments are possible by escaping the closing sequence <code>*/</code> as <code>*@/</code>. This can be useful when providing example code within a documentation comment.</p>"},{"location":"writing/#migration-support","title":"Migration support","text":"<p>To assist in the migration of existing code bases to Doxide from other documentation tools, some additional support is provided:</p> <ul> <li> <p>The character <code>\\</code> may be used as an alternative to <code>@</code> to denote commands. When <code>\\</code> is used, unlike when <code>@</code> is used, no warning is given if the command is not found, and the command is output as-is. This is necessary to support LaTeX macros in mathematics without warning overload.</p> </li> <li> <p>The character <code>%</code> may be used as an escape for a single non-whitespace character (it is used to break automatic linking in Doxygen).</p> </li> </ul> <p>The following behaviors are implemented to assist in the migration of existing code bases. Recommended alternatives are provided for new code bases.</p> Command(s) Doxide behavior Recommended alternative <code>@e word</code>, <code>@em word</code>, <code>@a word</code> Replace with Markdown. Use Markdown emphasis: <code>*word*</code> <code>@b word</code> Replace with Markdown. Use Markdown bold: <code>**word**</code> <code>@c word</code>, <code>@p word</code> Replace with Markdown. Use Markdown inline code: <code>`word`</code> <code>@f$ ... @f$</code> Replace with Markdown. Use Markdown inline math: <code>$ ... $</code> <code>@f\\[ ... @f]</code> Replace with Markdown. Use Markdown display math: <code>$$ ... $$</code>. <code>@li</code>, <code>@arg</code> Replace with Markdown. Use Markdown unordered list item: <code>-</code> <code>@code ... @endcode</code>, <code>@verbatim ... @endverbatim</code> Replace with Markdown. Use Markdown display code: <code>``` ... ```</code>. <code>@attention</code>, <code>@bug</code>, <code>@example</code>, <code>@note</code>, <code>@todo</code>, <code>@warning</code>, <code>@remark</code>, <code>@remarks</code> Replace with Markdown. Use Markdown admonition: <code>!!! type</code>. <code>@ref name text</code> Replace with Markdown. Use Markdown link: <code>[text](#name)</code> <code>@image format file alt</code> Ignored. Use Markdown image: <code>![alt](file)</code> <code>@returns</code>, <code>@result</code> As <code>@return</code>. Use <code>@return</code>. <code>@throws</code> , <code>@exception</code> As <code>@throw</code>. Use <code>@throw</code>. <code>@sa</code> As <code>@see</code>. Use <code>@see</code>. <code>@brief</code>, <code>@short</code> Ignored. Make the first sentence of the documentation comment usable as a brief description. <code>@internal</code> Documentation comment and entity are hidden. Use a normal comment, rather than a documentation comment. <code>@defgroup</code> Ignored. Doxide handles groups differently, see below. <code>@file</code> Ignored. Doxide does not produce documentation for files. Incorporate into the documentation for another entity, or into a custom page. <code>@def MACRO</code> Ignored. Doxide does not run the preprocessor. Add a documentation comment immediately before the <code>#define</code>. <code>@var name</code>, <code>@fn name</code>, <code>@class name</code>, <code>@struct name</code>, <code>@union name</code>, <code>@enum name</code>,  <code>@typedef name</code>, <code>@namespace name</code>, <code>@interface name</code>, <code>@protocol name</code>, <code>@property name</code>. Ignored. Add a documentation comment immediately before the relevant entity."},{"location":"demo/","title":"Demo","text":"<p>These pages demonstrate some of the features of Doxide, and also serve as a test corpus. They are generated from the source files in the demo directory of the repository, as well as from the source code of Doxide itself. This first page demonstrates how groups can be used to organize documentation.</p> Parsing Demonstration and test of some parsing capabilities, including basics such as variables, functions, operators and types, and more complex forms such as elaborate templates and SFINAE. Presentation Demonstration and test of Markdown elements, such as code, syntax highlighting, tables, images, and admonitions. Developer Doxide's own source code documentation. ns1 Namespace <code>ns1</code>. <p> Code Coverage</p>"},{"location":"demo/coverage/","title":"Code Coverage","text":"Name Lines Covered Uncovered Coverage demo 13 0 13 0.0% parsing.hpp 13 0 13 0.0% presentation.hpp 0 0 0 100.0% src 1476 896 580 60.7% CppParser.cpp 252 220 32 87.3% CppParser.hpp 0 0 0 100.0% Doc.cpp 161 120 41 74.5% Doc.hpp 0 0 0 100.0% DocToken.cpp 4 4 0 100.0% DocToken.hpp 11 0 11 0.0% DocTokenizer.cpp 15 14 1 93.3% DocTokenizer.hpp 0 0 0 100.0% Driver.cpp 135 69 66 51.1% Driver.hpp 0 0 0 100.0% Entity.cpp 159 93 66 58.5% Entity.hpp 0 0 0 100.0% GcovCounter.cpp 26 0 26 0.0% GcovCounter.hpp 0 0 0 100.0% JSONCounter.cpp 33 0 33 0.0% JSONCounter.hpp 0 0 0 100.0% JSONGenerator.cpp 32 11 21 34.4% JSONGenerator.hpp 0 0 0 100.0% MarkdownGenerator.cpp 483 267 216 55.3% MarkdownGenerator.hpp 0 0 0 100.0% SourceWatcher.cpp 25 0 25 0.0% SourceWatcher.hpp 0 0 0 100.0% YAMLNode.cpp 16 14 2 87.5% YAMLNode.hpp 12 6 6 50.0% YAMLParser.cpp 62 47 15 75.8% YAMLParser.hpp 0 0 0 100.0% doxide.cpp 49 31 18 63.3% doxide.hpp 1 0 1 0.0% Summary 13 0 13 0.0% Summary 1476 896 580 60.7% Summary 1489 896 593 60.2%"},{"location":"demo/coverage/demo/","title":"demo","text":"Name Lines Covered Uncovered Coverage parsing.hpp 13 0 13 0.0% presentation.hpp 0 0 0 100.0% Summary 13 0 13 0.0%"},{"location":"demo/coverage/demo/parsing.hpp/","title":"parsing.hpp","text":"<pre><code>/**\n * Test macro.\n * \n * @ingroup parsing\n */\n#define MACRO 0\n\n/**\n * Test macro with arguments.\n * \n * @ingroup parsing\n */\n#define MACRO_WITH_ARGS(x, y) (x + y)\n\n#define MACRO_AFTER 0\n///&lt; Test macro, documented after entity with `///` comment\n///&lt; @ingroup parsing\n\n#define MACRO_WITH_ARGS_AFTER(x, y) (x + y)\n///&lt; Test macro with arguments, documented after entity with `///` comment\n///&lt; @ingroup parsing\n\n/**\n * Forward class declaration.\n * \n * @ingroup parsing\n */\nclass ForwardClass;\n\n/**\n * Documented with `/** ... *@/` style preceding comment.\n * \n * @ingroup parsing\n */\nint a;\n\n/// Documented with `///` style preceding comment. @ingroup parsing\nint b;\n\n///\n/// Documented with `///` style preceding comment that wraps across multiple\n/// lines and has multiple paragraphs.\n///\n///This is the second paragraph.\n///\n/// @ingroup parsing\n///\n/// This is the third paragraph.\n///\nint c;\n\nint d;  ///&lt; Documented after entity with `///` comment @ingroup parsing\n\n/**\n * Documentation comment with * and / characters.\n *\n * @ingroup parsing\n */\nint e;\n\n/**\n * Comment where leading whitespace is important, using `/** ... *@/` style\n * preceding comment. Details should show code if indenting is correctly\n * preserved.\n *\n * @ingroup parsing\n *\n *     int main();\n */\nint whitespace1;\n\n/**\n * Comment where leading whitespace is important, using `///` style preceding\n * comment. Details should show code if indenting is correctly preserved.\n *\n * @ingroup parsing\n *\n *     int main();\n */\nint whitespace2;\n\n/**\n * Test variable.\n * \n * @ingroup parsing\n */\nint w;\n\n/**\n * Test variable with initializer.\n * \n * @ingroup parsing\n */\nint x = 0;\n\n/**\n * Test variable with parenthetical initializer.\n * \n * @ingroup parsing\n */\nint y(0);\n\n/**\n * Test variable with brace initializer.\n * \n * @ingroup parsing\n */\nint z{0};\n\n/**\n * Test variable of array type.\n * \n * @ingroup parsing\n */\nint arr1[10];\n\n/**\n * Test variable of reference type.\n * \n * @ingroup parsing\n */\nint&amp; ref1;\n\n/**\n * Test variable of pointer type.\n * \n * @ingroup parsing\n */\nint* ptr1;\n\n/**\n * Test variable of array type with initializer.\n * \n * @ingroup parsing\n */\nint arr2[10] = {0};\n\n/**\n * Test variable of reference type with initializer.\n * \n * @ingroup parsing\n */\nint&amp; ref2 = x;\n\n/**\n * Test variable of pointer type with initializer.\n * \n * @ingroup parsing\n */\nint* ptr2 = &amp;x;\n\n/**\n * Test variable with unicode character.\n * \n * @ingroup parsing\n */\nint \u03bb;\n\n/**\n * Test variable of function pointer type.\n * \n * @ingroup parsing\n */\nint (*fp)(int, int);\n\n/**\n * Test function.\n * \n * @ingroup parsing\n */\nint f(int x, int y);\n\n/**\n * Test function that returns a reference.\n * \n * @ingroup parsing\n */\nint&amp; f(int x, int y);\n\n/**\n * Test function that returns a pointer.\n * \n * @ingroup parsing\n */\nint* f(int x, int y);\n\n/**\n * Test function that returns a function pointer.\n * \n * @ingroup parsing\n */\nint (*f(int x, int y))(int, int);\n\n/**\n * Test function template.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T&gt;\nT f(T x, T y);\n\n/**\n * Test function template with SFINAE.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt;\nT f(T x, T y);\n\n/**\n * Test inline function.\n * \n * @ingroup parsing\n */\ninline int f(int x, int y) {\n  return 0;\n}\n\n/**\n * Test inline function template.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T&gt;\nT f(T x, T y) {\n  return T();\n}\n\n/**\n * Test inline function template with SFINAE.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt;\nT f(T x, T y) {\n  return T();\n}\n\n/**\n * Test operator.\n * \n * @ingroup parsing\n */\nint operator+(int x, int y);\n\n/**\n * Test operator template.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T&gt;\nT operator+(T x, T y);\n\n/**\n * Test operator template with SFINAE.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt;\nT operator+(T x, T y);\n\n/**\n * Test inline operator.\n * \n * @ingroup parsing\n */\ninline int operator+(int x, int y) {\n  return 0;\n}\n\n/**\n * Test inline operator template.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T&gt;\nT operator+(T x, T y) {\n  return T();\n}\n\n/**\n * Test inline operator template with SFINAE.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt;\nT operator+(T x, T y) {\n  return T();\n}\n\n/**\n * Test class.\n * \n * @ingroup parsing\n */\nclass Class {\n  //\n};\n\n/**\n * Test struct.\n * \n * @ingroup parsing\n */\nstruct Struct {\n  //\n};\n\n/**\n * Test union.\n * \n * @ingroup parsing\n */\nunion Union {\n  //\n};\n\n/**\n * Test class template.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T&gt;\nclass ClassTemplate {\n  //\n};\n\n/**\n * Test struct template.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T&gt;\nstruct StructTemplate {\n  //\n};\n\n/**\n * Test union template.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T&gt;\nunion UnionTemplate {\n  //\n};\n\n/**\n * Test typedef.\n * \n * @ingroup parsing\n */\ntypedef int TypeDef;\n\n/**\n * Test type alias.\n * \n * @ingroup parsing\n */\nusing TypeAlias = int;\n\n/**\n * Test typedef of function pointer type.\n * \n * @ingroup parsing\n */\ntypedef int (*TypeDefFunctionPointer)(int, int);\n\n/**\n * Test type alias of function pointer type.\n * \n * @ingroup parsing\n */\nusing TypeAliasFunctionPointer = int (*)(int, int);\n\n/**\n * Test type alias template.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T&gt;\nusing TypeAliasTemplate = int;\n\n/**\n * Test concept.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T&gt;\nconcept Concept = std::is_arithmetic_v&lt;T&gt;;\n\n/**\n * Test trivial concept.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T&gt;\nconcept TrivialConcept = true;\n\n/**\n * Test enumeration.\n * \n * @ingroup parsing\n */\nenum Enum {\n  /**\n   * First possibility.\n   */\n  FIRST,\n\n  /**\n   * Second possibility.\n   */\n  SECOND,\n\n  /**\n   * Third possibility.\n   */\n  THIRD\n};\n\n/**\n * Test enumeration with values documented after.\n * \n * @ingroup parsing\n */\nenum EnumAfter {\n  FIRST,   ///&lt; First possibility, document after with `///` comment\n  SECOND,  ///&lt; Second possibility, document after with `///` comment\n  THIRD    ///&lt; Third possibility, document after with `///` comment\n};\n\n/**\n * Test scoped enumeration.\n * \n * @ingroup parsing\n */\nenum class EnumClass {\n  /**\n   * First possibility.\n   */\n  FIRST,\n\n  /**\n   * Second possibility.\n   */\n  SECOND,\n\n  /**\n   * Third possibility.\n   */\n  THIRD\n};\n\n/**\n * Test scoped enumeration.\n * \n * @ingroup parsing\n */\nenum struct EnumStruct {\n  /**\n   * First possibility.\n   */\n  FIRST,\n\n  /**\n   * Second possibility.\n   */\n  SECOND,\n\n  /**\n   * Third possibility.\n   */\n  THIRD\n};\n\n/**\n * Class with members.\n * \n * @ingroup parsing\n */\nclass ClassWithMembers {\npublic:\n  /**\n   * Inner class.\n   */\n  class InnerClass {\n    /**\n     * Test member variable of inner class.\n     */\n    int w;\n  };\n\n  /**\n   * Inner enumeration.\n   */\n  enum InnerEnum {\n    /**\n     * First possibility.\n     */\n    FIRST,\n\n    /**\n     * Second possibility.\n     */\n    SECOND,\n\n    /**\n     * Third possibility.\n     */\n    THIRD\n  };\n\n  /**\n   * Inner typedef.\n   */\n  typedef int InnerTypeDef;\n\n  /**\n   * Inner type alias.\n   */\n  using InnerTypeAlias = int;\n\n  /**\n   * Test member variable.\n   */\n  int x;\n\n  /**\n   * Test member variable with initializer.\n   */\n  int y = 1;\n\n  /**\n   * Test member variable with brace initializer.\n   */\n  int z{0};\n\n  /**\n   * Test member variable of array type.\n   */\n  int arr1[10];\n\n  /**\n   * Test member variable of reference type.\n   */\n  int&amp; ref1;\n\n  /**\n   * Test member variable of pointer type.\n   */\n  int* ptr1;\n\n  /**\n   * Test member variable of array type with initializer.\n   */\n  int arr2[10] = {0};\n\n  /**\n   * Test member variable of reference type with initializer.\n   */\n  int&amp; ref2 = x;\n\n  /**\n   * Test member variable of pointer type with initializer.\n   */\n  int* ptr2 = &amp;x;\n\n  /**\n   * Test member variable with unicode character.\n   */\n  int \u03bb;\n\n  /**\n   * Test member variable of function pointer type.\n   */\n  int (*fp)(int, int);\n\n  /**\n   * Test constructor.\n   */\n  ClassWithMembers();\n\n  /**\n   * Test destructor.\n   */\n  ~ClassWithMembers();\n\n  /**\n   * Test member function.\n   */\n  int f(int x, int y);\n\n  /**\n   * Test member function that returns a reference.\n   */\n  int&amp; f(int x, int y);\n\n  /**\n   * Test member function that returns a pointer.\n   */\n  int* f(int x, int y);\n\n  /**\n   * Test member function that returns a function pointer.\n   */\n  int (*f(int x, int y))(int, int);\n\n  /**\n   * Test member function template.\n   */\n  template&lt;class T&gt;\n  T f(T x, T y);\n\n  /**\n   * Test member function template with SFINAE.\n   */\n  template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt;\n  T f(T x, T y);\n\n  /**\n   * Test inline member function.\n   */\n  inline int f(int x, int y) {\n    return 0;\n  }\n\n  /**\n   * Test inline member function template.\n   */\n  template&lt;class T&gt;\n  T f(T x, T y) {\n    return T();\n  }\n\n  /**\n   * Test inline member function template with SFINAE.\n   */\n  template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt;\n  T f(T x, T y) {\n    return T();\n  }\n\n  /**\n   * Test member operator.\n   */\n  int operator+(int x, int y);\n\n  /**\n   * Test member operator template.\n   */\n  template&lt;class T&gt;\n  T operator+(T x, T y);\n\n  /**\n   * Test member function template with SFINAE.\n   */\n  template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt;\n  T operator+(T x, T y);\n\n  /**\n   * Test inline member operator.\n   */\n  inline int operator+(int x, int y) {\n    return 0;\n  }\n\n  /**\n   * Test inline member operator template.\n   */\n  template&lt;class T&gt;\n  T operator+(T x, T y) {\n    return T();\n  }\n\n  /**\n   * Test inline member operator template with SFINAE.\n   */\n  template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt;\n  T operator+(T x, T y) {\n    return T();\n  }\n\n  /**\n   * Test assignment operator.\n   */\n  ClassWithMembers&amp; operator=(const ClassWithMembers&amp; o);\n\n  /**\n   * Test conversion operator declaration.\n   */\n  operator int() const;\n\n  /**\n   * Test reference conversion operator declaration.\n   */\n  operator int&amp;() const;\n\n  /**\n   * Test pointer conversion operator declaration.\n   */\n  operator int*() const;\n\n  /**\n   * Test conversion operator definition.\n   */\n  operator double() const {\n    return 0.0;\n  }\n\n  /**\n   * Attempt to move a member out of its class with `@ingroup`, but should\n   * remain in `ClassWithMembers`.\n   * \n   * @ingroup parsing\n   */\n  int escapee;\n};\n\n/**\n * Class template with members.\n * \n * @ingroup parsing\n */\ntemplate&lt;class T&gt;\nclass ClassTemplateWithMembers {\npublic:\n  /**\n   * Test member variable.\n   */\n  int w;\n};\n\n/**\n * Namespace `ns1`.\n */\nnamespace ns1 {\n  /**\n   * Namespace `ns1::ns2a`.\n   */\n  namespace ns2a {\n    //\n  }\n}\n\n/**\n * Namespace `ns1::ns2b` declared with nested namespace specifier.\n */\nnamespace ns1::ns2b {\n  //\n}\n\n/**\n * Namespace `ns1::ns2a::ns3` declared with nested namespace specifier.\n */\nnamespace ns1::ns2a::ns3 {\n  //\n}\n</code></pre>"},{"location":"demo/coverage/demo/presentation.hpp/","title":"presentation.hpp","text":"<pre><code>/**\n * Function with documentation demonstrating various presentation features.\n * \n * @ingroup presentation\n * \n * #### Lists\n *\n * Itemized list:\n * \n *   - Itemized list item.\n *   - Itemized list item.\n *     - Nested itemized list item.\n *   - Itemized list item.\n * \n * Numbered list:\n * \n *   1. Enumerated list item.\n *   2. Enumerated list item.\n *     - Nested itemized list item.\n *   3. Enumerated list item.\n * \n * #### Tables\n * \n * | Column 1 | Column 2 | Column 3 |\n * | -------- | -------- | -------- |\n * | Row 1, Column 1 | Row 1, Column 2 | Row 1, Column 3 |\n * | Row 2, Column 1 | Row 2, Column 2 | Row 2, Column 3 |\n * | Row 3, Column 1 | Row 3, Column 2 | Row 3, Column 3 |\n * \n * #### Code\n * \n * ```cpp\n * void f(int x, int y);\n * ```\n *\n * ```cpp\n * /* nested comment in code *@/\n * void f(int x, int y);\n * ```\n * \n * #### Images\n * \n * ![Doxide logo](/assets/logo_red.svg){width=\"256\"}\n * \n * #### Headings\n * \n * ##### Heading 5\n * \n * ###### Heading 6\n * \n * #### Admonitions\n * \n * @note\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n * \n * @abstract\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n * \n * @info\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n * \n * @tip\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n * \n * @success\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n * \n * @question\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n * \n * @warning\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n * \n * @failure\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n * \n * @danger\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n * \n * @bug\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n * \n * @example\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n * \n * @quote\n * Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n * tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n * veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n * commodo consequat.\n */\nint f(int x, int y);\n\n/// Function with documentation demonstrating various presentation features,\n/// this time using end-of-line comments.\n/// \n/// @ingroup presentation\n/// \n/// #### Lists\n///\n/// Itemized list:\n/// \n///   - Itemized list item.\n///   - Itemized list item.\n///   - Itemized list item.\n/// \n/// Numbered list:\n/// \n///   1. Enumerated list item.\n///   2. Enumerated list item.\n///   3. Enumerated list item.\n/// \n/// #### Tables\n/// \n/// | Column 1 | Column 2 | Column 3 |\n/// | -------- | -------- | -------- |\n/// | Row 1, Column 1 | Row 1, Column 2 | Row 1, Column 3 |\n/// | Row 2, Column 1 | Row 2, Column 2 | Row 2, Column 3 |\n/// | Row 3, Column 1 | Row 3, Column 2 | Row 3, Column 3 |\n/// \n/// #### Code\n/// \n/// ```cpp\n/// void f(int x, int y);\n/// ```\n///\n/// ```cpp\n/// /// nested comment in code\n/// void f(int x, int y);\n/// ```\n/// \n/// #### Images\n/// \n/// ![Doxide logo](/assets/logo_red.svg){width=\"256\"}\n/// \n/// #### Headings\n/// \n/// ##### Heading 5\n/// \n/// ###### Heading 6\n/// \n/// #### Admonitions\n/// \n/// @note\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n/// \n/// @abstract\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n/// \n/// @info\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n/// \n/// @tip\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n/// \n/// @success\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n/// \n/// @question\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n/// \n/// @warning\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n/// \n/// @failure\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n/// \n/// @danger\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n/// \n/// @bug\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n/// \n/// @example\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n/// \n/// @quote\n/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n/// tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n/// veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n/// commodo consequat.\n///\nint g(int x, int y);\n\n/**\n * Function demonstrating all possible annotations.\n * \n * @ingroup presentation\n * \n * @tparam T Template parameter.\n * \n * @param x Input parameter.\n * @param[in] y Input parameter.\n * @param[out] z Output parameter.\n * @param[in,out] w Input-output parameter.\n * @param u Input parameter with a description that spans across multiple\n * lines.\n * \n * @return Return value.\n * \n * @pre Pre-condition.\n * @post Post-condition.\n * @throw Exception.\n * \n * @see [f](#f)\n */\ntemplate&lt;class T&gt;\nint h(int x, int y, int&amp; z, int&amp; w);\n\n/// Function demonstrating all possible annotations, this time using\n/// end-of-line comments.\n/// \n/// @ingroup presentation\n/// \n/// @tparam T Template parameter.\n/// \n/// @param x Input parameter.\n/// @param[in] y Input parameter.\n/// @param[out] z Output parameter.\n/// @param[in,out] w Input-output parameter.\n/// @param u Input parameter with a description that spans across multiple\n/// lines.\n/// \n/// @return Return value.\n/// \n/// @pre Pre-condition.\n/// @post Post-condition.\n/// @throw Exception.\n/// \n/// @see [f](#f)\ntemplate&lt;class T&gt;\nint i(int x, int y, int&amp; z, int&amp; w);\n</code></pre>"},{"location":"demo/coverage/src/","title":"src","text":"Name Lines Covered Uncovered Coverage CppParser.cpp 252 220 32 87.3% CppParser.hpp 0 0 0 100.0% Doc.cpp 161 120 41 74.5% Doc.hpp 0 0 0 100.0% DocToken.cpp 4 4 0 100.0% DocToken.hpp 11 0 11 0.0% DocTokenizer.cpp 15 14 1 93.3% DocTokenizer.hpp 0 0 0 100.0% Driver.cpp 135 69 66 51.1% Driver.hpp 0 0 0 100.0% Entity.cpp 159 93 66 58.5% Entity.hpp 0 0 0 100.0% GcovCounter.cpp 26 0 26 0.0% GcovCounter.hpp 0 0 0 100.0% JSONCounter.cpp 33 0 33 0.0% JSONCounter.hpp 0 0 0 100.0% JSONGenerator.cpp 32 11 21 34.4% JSONGenerator.hpp 0 0 0 100.0% MarkdownGenerator.cpp 483 267 216 55.3% MarkdownGenerator.hpp 0 0 0 100.0% SourceWatcher.cpp 25 0 25 0.0% SourceWatcher.hpp 0 0 0 100.0% YAMLNode.cpp 16 14 2 87.5% YAMLNode.hpp 12 6 6 50.0% YAMLParser.cpp 62 47 15 75.8% YAMLParser.hpp 0 0 0 100.0% doxide.cpp 49 31 18 63.3% doxide.hpp 1 0 1 0.0% Summary 1476 896 580 60.7%"},{"location":"demo/coverage/src/CppParser.cpp/","title":"CppParser.cpp","text":"<pre><code>#include \"CppParser.hpp\"\n#include \"Doc.hpp\"\n\n/**\n * Query for entities in C++ sources.\n * \n * @ingroup developer\n */\nstatic const char* query_cpp = R\"\"\"\"(\n[\n  ;; documentation\n  (comment) @docs\n\n  ;; namespace definition\n  (namespace_definition\n      name: (namespace_identifier) @name\n      body: (declaration_list)? @body) @namespace\n\n  ;; nested namespace definition---matches once for each @name\n  (namespace_definition\n      (nested_namespace_specifier) @nested_name\n      body: (declaration_list)? @body) @namespace\n\n  ;; template declaration\n  (template_declaration\n      [\n        (class_specifier)\n        (struct_specifier)\n        (union_specifier)\n        (alias_declaration)\n        (concept_definition)\n        (declaration)\n        (field_declaration)\n        (function_definition)\n      ] @body) @template\n\n  ;; class definition\n  (class_specifier\n      name: [\n        (type_identifier) @name\n        (template_type) @name  ;; for template specialization\n      ]\n      body: (field_declaration_list)? @body\n      ) @type\n\n  ;; struct definition\n  (struct_specifier\n      name: [\n        (type_identifier) @name\n        (template_type) @name  ;; for template specialization\n      ]\n      body: (field_declaration_list)? @body\n      ) @type\n\n  ;; union definition\n  (union_specifier\n      name: [\n        (type_identifier) @name\n        (template_type) @name  ;; for template specialization\n      ]\n      body: (field_declaration_list)? @body\n      ) @type\n\n  ;; enum definition\n  (enum_specifier\n      name: (type_identifier) @name\n      body: (enumerator_list)? @body\n      ) @type\n\n  ;; typedef\n  (type_definition\n      declarator: [\n        (type_identifier) @name\n\n        ;; for function pointer types\n        (function_declarator\n          declarator: (parenthesized_declarator\n            (pointer_declarator\n              declarator: (type_identifier) @name)\n          )\n        )\n        (pointer_declarator\n          declarator: (function_declarator\n            declarator: (type_identifier) @name)\n        )\n      ]) @typedef\n\n  ;; type alias\n  (alias_declaration\n      name: (type_identifier) @name) @typedef\n\n  ;; concept\n  (concept_definition\n      name: (identifier) @name\n      (_)) @concept\n\n  ;; variable\n  (declaration\n      declarator: [\n        (identifier) @name\n        (array_declarator (identifier) @name)\n        (reference_declarator (identifier) @name)\n        (pointer_declarator (identifier) @name)\n        (init_declarator\n          declarator: [\n            (identifier) @name\n            (array_declarator (identifier) @name)\n            (reference_declarator (identifier) @name)\n            (pointer_declarator (identifier) @name)\n          ]\n          value: (_) @value)\n\n        ;; for function pointer types\n        (function_declarator\n          declarator: (parenthesized_declarator\n            (pointer_declarator\n              declarator: (identifier) @name)\n          )\n        )\n      ]\n      default_value: (_)? @value\n    ) @variable\n\n  ;; member variable\n  (field_declaration\n      declarator: [\n        (field_identifier) @name\n        (array_declarator (field_identifier) @name)\n        (reference_declarator (field_identifier) @name)\n        (pointer_declarator (field_identifier) @name)\n        (init_declarator\n          declarator: [\n            (identifier) @name\n            (field_identifier) @name\n            (array_declarator (identifier) @name)\n            (array_declarator (field_identifier) @name)\n            (reference_declarator (identifier) @name)\n            (reference_declarator (field_identifier) @name)\n            (pointer_declarator (identifier) @name)\n            (pointer_declarator (field_identifier) @name)\n          ]\n          value: (_) @value)\n\n        ;; for function pointer types\n        (function_declarator\n          declarator: (parenthesized_declarator\n            (pointer_declarator\n              declarator: (field_identifier) @name)\n          )\n        )\n      ]\n      default_value: (_)? @value\n    ) @variable\n\n  ;; function declaration\n  (declaration\n      declarator: [\n        (function_declarator\n          declarator: (identifier) @name\n        )\n        (reference_declarator\n          (function_declarator\n            declarator: (identifier) @name\n          )\n        )\n        (pointer_declarator\n          (function_declarator\n            declarator: (identifier) @name\n          )\n        )\n        (function_declarator  ;; for function pointer return types\n          declarator: (parenthesized_declarator\n            (pointer_declarator\n              (function_declarator\n                declarator: (identifier) @name\n              )\n            )\n          )\n        )\n      ]\n    ) @function\n\n  ;; member function declaration\n  (field_declaration\n      declarator: [\n        (function_declarator\n          declarator: [\n            (identifier) @name\n            (field_identifier) @name\n          ]\n        )\n        (reference_declarator\n          (function_declarator\n            declarator: [\n              (identifier) @name\n              (field_identifier) @name\n            ]\n          )\n        )\n        (pointer_declarator\n          (function_declarator\n            declarator: [\n              (identifier) @name\n              (field_identifier) @name\n            ]\n          )\n        )\n        (function_declarator  ;; for function pointer return types\n          declarator: (parenthesized_declarator\n            (pointer_declarator\n              (function_declarator\n                declarator: [\n                  (identifier) @name\n                  (field_identifier) @name\n                ]\n              )\n            )\n          )\n        )\n      ]\n    ) @function\n\n  ;; function definition\n  (function_definition\n      declarator: [\n        (function_declarator\n          declarator: [\n            (identifier) @name\n            (field_identifier) @name\n            (destructor_name) @name\n          ]\n        )\n        (reference_declarator\n          (function_declarator\n            declarator: [\n              (identifier) @name\n              (field_identifier) @name\n              (destructor_name) @name\n            ]\n          )\n        )\n        (pointer_declarator\n          (function_declarator\n            declarator: [\n              (identifier) @name\n              (field_identifier) @name\n              (destructor_name) @name\n            ]\n          )\n        )\n\n        ;; for function pointer return types\n        (function_declarator\n          declarator: (parenthesized_declarator\n            (pointer_declarator\n              (function_declarator\n                declarator: [\n                  (identifier) @name\n                  (field_identifier) @name\n                  (destructor_name) @name\n                ]\n              )\n            )\n          )\n        )\n      ]\n      [\n        (field_initializer_list)\n        body: (_)\n      ] @body\n    ) @function\n\n  ;; constructor &amp; destructor declaration\n  (declaration\n      declarator: [\n        (function_declarator\n          declarator: [\n          (identifier) @name\n          (field_identifier) @name\n          (destructor_name) @name\n          ]\n        )\n      ]\n    ) @function\n\n  ;; operator declaration\n  (declaration\n      declarator: [\n        (function_declarator\n          declarator: (operator_name) @name\n        )\n        (reference_declarator\n          (function_declarator\n            declarator: (operator_name) @name\n          )\n        )\n        (pointer_declarator\n          (function_declarator\n            declarator: (operator_name) @name\n          )\n        )\n        (operator_cast\n          type: (_) @name\n        )\n      ]\n    ) @operator\n\n  ;; member operator declaration\n  (field_declaration\n      declarator: [\n        (function_declarator\n          declarator: (operator_name) @name\n        )\n        (reference_declarator\n          (function_declarator\n            declarator: (operator_name) @name\n          )\n        )\n        (pointer_declarator\n          (function_declarator\n            declarator: (operator_name) @name\n          )\n        )\n        (operator_cast\n          type: (_) @name\n        )\n      ]\n    ) @operator\n\n  ;; member operator definition\n  (function_definition\n      declarator: [\n        (function_declarator\n          declarator: (operator_name) @name\n        )\n        (reference_declarator\n          (function_declarator\n            declarator: (operator_name) @name\n          )\n        )\n        (pointer_declarator\n          (function_declarator\n            declarator: (operator_name) @name\n          )\n        )\n        (operator_cast\n          type: (_) @name\n        )\n      ]\n      body: (_) @body\n    ) @operator\n\n  ;; enumeration value\n  (enumerator\n       name: (identifier) @name) @enumerator\n\n  ;; macro\n  (preproc_def\n      name: (identifier) @name\n      value: (_) @value) @macro\n  (preproc_function_def\n      name: (identifier) @name\n      value: (_) @value) @macro\n]\n)\"\"\"\";\n\n/**\n * Query for entities to explicitly exclude from  line counts in C++ sources.\n * \n * @ingroup developer\n */\nstatic const char* query_cpp_exclude = R\"\"\"\"(\n[\n  ;; types and parameter default values may contain expressions\n  (_ type: (_) @exclude)\n  (_ default_value: (_) @exclude)\n\n  ;; template arguments in template specializations may contain expressions\n  (class_specifier name: (_) @exclude)\n  (struct_specifier name: (_) @exclude)\n  (union_specifier name: (_) @exclude)\n\n  ;; constexpr context\n  (requires_clause) @exclude\n  (static_assert_declaration) @exclude\n  (type_definition) @exclude\n  (alias_declaration) @exclude\n  (concept_definition) @exclude\n  (preproc_def) @exclude\n  (preproc_function_def) @exclude\n  (decltype) @exclude\n  (sizeof_expression) @exclude\n  (enum_specifier) @exclude\n\n  ;; if statement may be if constexpr, special handling in code for this\n  (if_statement condition: (_) @then_exclude) @if_constexpr\n  (declaration (type_qualifier) @if_constexpr declarator: (_) @then_exclude)\n]\n)\"\"\"\";\n\n/**\n * Query for entities to explicitly include in line counts in C++ sources.\n * \n * @ingroup developer\n */\nstatic const char* query_cpp_include = R\"\"\"\"(\n[\n  (unary_expression operator: _ @executable)\n  (binary_expression operator: _ @executable)\n  (assignment_expression operator: _ @executable)\n  (fold_expression operator: _ @executable)\n  (field_expression operator: _ @executable)\n  (co_await_expression operator: _ @executable)\n  (new_expression) @executable\n  (delete_expression) @executable\n  (update_expression) @executable\n  (subscript_expression) @executable\n  (field_initializer) @executable\n  (for_range_loop right: _ @executable)\n  (return_statement) @executable\n  (co_return_statement) @executable\n  (co_yield_statement) @executable\n\n  ;; function calls are complicated by higher-order functions, including\n  ;; lambda use such as [](auto x){ return f(x); }(x); anchor on some simpler\n  ;; cases\n  (call_expression\n    function: [\n      (identifier)\n      (qualified_identifier)\n      (template_function)\n    ] @executable)\n\n]\n)\"\"\"\";\n\nCppParser::CppParser() :\n    parser(nullptr),\n    query(nullptr),\n    query_exclude(nullptr),\n    query_include(nullptr) {\n  uint32_t error_offset;\n  TSQueryError error_type;\n\n  /* parser */\n  parser = ts_parser_new();\n  ts_parser_set_language(parser, tree_sitter_cuda());\n\n  /* queries */\n  query = ts_query_new(tree_sitter_cuda(), query_cpp,\n      uint32_t(strlen(query_cpp)), &amp;error_offset, &amp;error_type);\n  if (error_type != TSQueryErrorNone) {\n    std::string_view from(query_cpp + error_offset,\n        std::min(size_t(40), strlen(query_cpp) - error_offset));\n    error(\"invalid query starting '\" &lt;&lt; from &lt;&lt; \"'...\");\n  }\n\n  query_exclude = ts_query_new(tree_sitter_cuda(), query_cpp_exclude,\n      uint32_t(strlen(query_cpp_exclude)), &amp;error_offset, &amp;error_type);\n  if (error_type != TSQueryErrorNone) {\n    std::string_view from(query_cpp_exclude + error_offset,\n        std::min(size_t(40), strlen(query_cpp_exclude) - error_offset));\n    error(\"invalid query starting '\" &lt;&lt; from &lt;&lt; \"'...\");\n  }\n\n  query_include = ts_query_new(tree_sitter_cuda(), query_cpp_include,\n      uint32_t(strlen(query_cpp_include)), &amp;error_offset, &amp;error_type);\n  if (error_type != TSQueryErrorNone) {\n    std::string_view from(query_cpp_include + error_offset,\n        std::min(size_t(40), strlen(query_cpp_include) - error_offset));\n    error(\"invalid query starting '\" &lt;&lt; from &lt;&lt; \"'...\");\n  }\n}\n\nCppParser::~CppParser() {\n  ts_query_delete(query);\n  ts_query_delete(query_exclude);\n  ts_query_delete(query_include);\n  ts_parser_delete(parser);\n}\n\nvoid CppParser::parse(const std::filesystem::path&amp; filename,\n    const std::unordered_map&lt;std::string,std::string&gt;&amp; defines,\n    Entity&amp; root) {\n  assert(entities.empty());\n  assert(starts.empty());\n  assert(ends.empty());\n\n  /* entity to represent file */\n  Entity file;\n  file.name = filename.filename().string();\n  file.decl = preprocess(filename, defines);\n  file.path = filename;\n  file.start_line = 0;\n  file.end_line = 0;\n  file.type = EntityType::FILE;\n  file.visible = true;\n\n  /* parse */\n  TSTree* tree = ts_parser_parse_string(parser, NULL, file.decl.data(),\n      uint32_t(file.decl.size()));\n  if (!tree) {\n    /* something went very wrong */\n    warn(\"cannot parse \" &lt;&lt; filename &lt;&lt; \", skipping\");\n    return;\n  } else {\n    /* report on any remaining parse errors */\n    report(filename, file.decl, tree);\n  }\n\n  /* query entity information */\n  TSNode node = ts_tree_root_node(tree);\n\n  file.start_line = 0;\n  file.end_line = ts_node_end_point(node).row;\n  file.line_counts.resize(file.end_line, -1);\n\n  /* push root entity to stack */\n  push(std::move(root), ts_node_start_byte(node), ts_node_end_byte(node));\n\n  TSQueryCursor* cursor = ts_query_cursor_new();\n  ts_query_cursor_exec(cursor, query, node);\n  TSQueryMatch match;\n  Entity entity;\n  int indent = 0;\n  while (ts_query_cursor_next_match(cursor, &amp;match)) {    \n    uint32_t start = 0, middle = 0, end = 0;\n    uint32_t start_line = -1, end_line = -1;\n    for (uint16_t i = 0; i &lt; match.capture_count; ++i) {\n      node = match.captures[i].node;\n      uint32_t id = match.captures[i].index; \n      uint32_t length = 0;\n      const char* name = ts_query_capture_name_for_id(query, id, &amp;length);\n      uint32_t k = ts_node_start_byte(node);\n      uint32_t l = ts_node_end_byte(node);\n\n      if (strncmp(name, \"docs\", length) == 0) {\n        Doc doc(file.decl.substr(k, l - k), indent);\n        Entity&amp; e = doc.open.type == OPEN_BEFORE ? entity : entities.back();\n        e.docs.append(doc.docs);\n        e.hide = e.hide || doc.hide;\n        e.visible = !e.docs.empty();\n        if (!doc.ingroup.empty()) {\n          e.ingroup = doc.ingroup;\n        }\n        indent = doc.indent;\n      } else if (strncmp(name, \"nested_name\", length) == 0) {\n        assert(entity.type == EntityType::NAMESPACE);\n\n        /* pop the stack down to parent */\n        pop(start, end);\n\n        /* nested namespace specifier, e.g. `namespace a::b::c`, split up the\n         * name on `::`, push namespaces for the first n - 1 identifiers, and\n         * assign the last as the name of this entity */\n        static const std::regex sep(\"\\\\s*::\\\\s*\", regex_flags);\n\n        /* load into a std::string and use std::sregex_token_iterator;\n         * maintaining the std::string_view and using\n         * std::cregex_token_iterator seems to have memory issues when mixed\n         * with other local variables */\n        std::string name = file.decl.substr(k, l - k);\n        std::sregex_token_iterator ns_iter(name.begin(), name.end(), sep, -1);\n        std::sregex_token_iterator ns_end;\n        assert(ns_iter != ns_end);\n        std::string prev = *ns_iter;  // lag one\n        while (++ns_iter != ns_end) {\n          /* create parent entity */\n          Entity parent;\n          parent.type = EntityType::NAMESPACE;\n          parent.name = prev;\n\n          push(std::move(parent), start, end);\n          prev = *ns_iter;\n        }\n        entity.name = prev;\n      } else if (strncmp(name, \"name\", length) == 0) {\n        entity.name = file.decl.substr(k, l - k);\n      } else if (strncmp(name, \"body\", length) == 0) {\n        middle = ts_node_start_byte(node);\n      } else if (strncmp(name, \"value\", length) == 0) {\n        middle = ts_node_start_byte(node);\n      } else {\n        start = ts_node_start_byte(node);\n        start_line = ts_node_start_point(node).row;\n        end = ts_node_end_byte(node);\n        end_line = ts_node_end_point(node).row;\n        middle = end;\n\n        if (strncmp(name, \"namespace\", length) == 0) {\n          entity.type = EntityType::NAMESPACE;\n        } else if (strncmp(name, \"template\", length) == 0) {\n          entity.type = EntityType::TEMPLATE;\n        } else if (strncmp(name, \"type\", length) == 0) {\n          entity.type = EntityType::TYPE;\n        } else if (strncmp(name, \"typedef\", length) == 0) {\n          entity.type = EntityType::TYPEDEF;\n        } else if (strncmp(name, \"concept\", length) == 0) {\n          entity.type = EntityType::CONCEPT;\n        } else if (strncmp(name, \"variable\", length) == 0) {\n          entity.type = EntityType::VARIABLE;\n        } else if (strncmp(name, \"function\", length) == 0) {\n          entity.type = EntityType::FUNCTION;\n        } else if (strncmp(name, \"operator\", length) == 0) {\n          entity.type = EntityType::OPERATOR;\n        } else if (strncmp(name, \"enumerator\", length) == 0) {\n          entity.type = EntityType::ENUMERATOR;\n        } else if (strncmp(name, \"macro\", length) == 0) {\n          entity.type = EntityType::MACRO;\n        }\n      }\n    }\n    if (entity.type != EntityType::ROOT) {\n      /* workaround for entity declaration logic catching punctuation, e.g.\n       * ending semicolon in declaration, the equals sign in a variable\n       * declaration with initialization, or whitespace */\n      while (middle &gt; start &amp;&amp; (file.decl[middle - 1] == ' ' ||\n          file.decl[middle - 1] == '\\t' ||\n          file.decl[middle - 1] == '\\n' ||\n          file.decl[middle - 1] == '\\r' ||\n          file.decl[middle - 1] == '\\\\' ||\n          file.decl[middle - 1] == '=' ||\n          file.decl[middle - 1] == ';')) {\n        --middle;\n      }\n\n      entity.decl = file.decl.substr(start, middle - start);\n      entity.path = filename;\n      entity.start_line = start_line;\n      entity.end_line = end_line;\n      entity.visible = !entity.docs.empty();\n\n      /* the final node represents the whole entity, pop the stack until we\n       * find its direct parent, as determined using nested byte ranges */\n      Entity&amp; parent = pop(start, end);\n\n      /* override ingroup for entities that belong to a class or template, as\n       * cannot be moved out */\n      if (parent.type == EntityType::TYPE ||\n          parent.type == EntityType::TEMPLATE) {\n        entity.ingroup.clear();\n      }\n\n      /* push to stack */\n      if (parent.type == EntityType::TEMPLATE) {\n        /* merge this entity into the template */\n        parent.merge(std::move(entity));\n      } else {\n        push(std::move(entity), start, end);\n      }\n\n      /* reset */\n      entity.clear();\n    }\n  }\n\n  /* finalize entity information */\n  root = std::move(pop());\n\n  entities.pop_back();\n  starts.pop_back();\n  ends.pop_back();\n\n  ts_query_cursor_delete(cursor);\n\n  /* determine excluded byte ranges for code coverage */\n  std::list&lt;std::pair&lt;uint32_t,uint32_t&gt;&gt; excluded;\n  bool constexpr_context = false;\n  static const std::regex regex_if_constexpr(\"^(?:if\\\\s+)?constexpr\",\n      regex_flags);\n  cursor = ts_query_cursor_new();\n  node = ts_tree_root_node(tree);\n  ts_query_cursor_exec(cursor, query_exclude, node);\n  while (ts_query_cursor_next_match(cursor, &amp;match)) {    \n    for (uint16_t i = 0; i &lt; match.capture_count; ++i) {\n      node = match.captures[i].node;\n      uint32_t id = match.captures[i].index; \n      uint32_t length = 0;\n      uint32_t start = ts_node_start_byte(node);\n      uint32_t end = ts_node_end_byte(node);\n      const char* name = ts_query_capture_name_for_id(query_exclude, id,\n          &amp;length);\n      if (strncmp(name, \"exclude\", length) == 0) {\n        /* exclude any expressions in this region for line data */\n        excluded.push_back(std::make_pair(start, end));\n      } else if (strncmp(name, \"if_constexpr\", length) == 0) {\n        /* check if this is `constexpr`, which is not reflected in the\n         * parse tree and requires a string comparison */\n        std::string stmt = file.decl.substr(start, end - start);\n        constexpr_context = std::regex_search(stmt, regex_if_constexpr);\n      } else if (strncmp(name, \"then_exclude\", length) == 0) {\n        /* to be excluded if the last constexpr check was positive */\n        if (constexpr_context) {\n          excluded.push_back(std::make_pair(start, end));\n          constexpr_context = false;\n        }\n      }\n    }\n  }\n  ts_query_cursor_delete(cursor);\n\n  /* determine included lines for code coverage */\n  cursor = ts_query_cursor_new();\n  node = ts_tree_root_node(tree);\n  ts_query_cursor_exec(cursor, query_include, node);\n  while (ts_query_cursor_next_match(cursor, &amp;match)) {\n    for (uint16_t i = 0; i &lt; match.capture_count; ++i) {\n      node = match.captures[i].node;\n      uint32_t id = match.captures[i].index; \n      uint32_t length = 0;\n      uint32_t start = ts_node_start_byte(node);\n      uint32_t end = ts_node_end_byte(node);\n      const char* name = ts_query_capture_name_for_id(query_include, id,\n          &amp;length);\n      if (strncmp(name, \"executable\", length) == 0) {\n        /* executable code, update line data as long as the code is not\n         * within an excluded region */\n        bool exclude = std::any_of(excluded.begin(), excluded.end(),\n            [start,end](auto range) {\n              return range.first &lt;= start &amp;&amp; end &lt;= range.second;\n            });\n        if (!exclude) {\n          uint32_t start_line = ts_node_start_point(node).row;\n          uint32_t end_line = ts_node_end_point(node).row;\n          for (uint32_t line = start_line; line &lt;= end_line; ++line) {\n            if (file.line_counts[line] &lt; 0) {\n              file.line_counts[line] = 0;\n              ++file.lines_included;\n            }\n          }\n        }\n      }\n    }\n  }\n  ts_query_cursor_delete(cursor);\n\n  /* finish up */\n  root.add(std::move(file));\n  ts_tree_delete(tree);\n  ts_parser_reset(parser);  \n\n  assert(entities.empty());\n  assert(starts.empty());\n  assert(ends.empty());\n}\n\nvoid CppParser::push(Entity&amp;&amp; entity, const uint32_t start, const uint32_t end) {\n  entities.push_back(std::move(entity));\n  starts.push_back(start);\n  ends.push_back(end);\n}\n\nEntity&amp; CppParser::pop(const uint32_t start, const uint32_t end) {\n  while (entities.size() &gt; 1 &amp;&amp;\n      (start &lt; starts.back() || ends.back() &lt; end ||\n      (start == 0 &amp;&amp; end == 0))) {\n    Entity back = std::move(entities.back());\n    entities.pop_back();\n    if (back.ingroup.empty()) {\n      entities.back().add(std::move(back));\n    } else {\n      entities.front().add(std::move(back));\n    }\n    starts.pop_back();\n    ends.pop_back();\n  }\n  return entities.back();\n}\n\nstd::string CppParser::preprocess(const std::filesystem::path&amp; filename,\n    const std::unordered_map&lt;std::string,std::string&gt;&amp; defines) {\n  /* regex to detect preprocessor macro names */\n  static const std::regex macro(R\"([A-Z_][A-Z0-9_]{2,})\",\n      regex_flags);\n\n  std::string in = gulp(filename);\n  TSTree* tree = ts_parser_parse_string(parser, NULL, in.data(),\n      uint32_t(in.size()));\n  TSNode root = ts_tree_root_node(tree);\n  TSNode node = root;\n  TSTreeCursor cursor = ts_tree_cursor_new(root);\n  do {\n    uint32_t k = ts_node_start_byte(node);\n    uint32_t l = ts_node_end_byte(node);\n    TSPoint from = ts_node_start_point(node);\n    bool nextNodeChosen = false;\n\n    if (defines.contains(in.substr(k, l - k))) {\n      /* replace preprocessor macro */\n      const std::string&amp; value = defines.at(in.substr(k, l - k));\n      uint32_t old_size = uint32_t(in.size());\n      in.replace(k, l - k, value);\n      uint32_t new_size = uint32_t(in.size());\n      TSPoint root_to = ts_node_end_point(root);\n\n      /* update tree */\n      TSInputEdit edit{k, old_size, new_size, from, root_to, root_to};\n      ts_tree_edit(tree, &amp;edit);\n      ts_parser_reset(parser);\n      TSTree* old_tree = tree;\n      tree = ts_parser_parse_string(parser, old_tree, in.data(),\n          uint32_t(in.size()));\n      ts_tree_delete(old_tree);\n      root = ts_tree_root_node(tree);\n\n      /* restore cursor to same byte position as edit */\n      ts_tree_cursor_reset(&amp;cursor, root);\n      while (ts_tree_cursor_goto_first_child_for_byte(&amp;cursor, k) &gt;= 0);\n\n      /* next iteration from this position */\n      nextNodeChosen = true;\n    }\n\n    /* next node */\n    if (!nextNodeChosen) {\n      if (strcmp(ts_node_type(node), \"preproc_def\") != 0 &amp;&amp;\n          strcmp(ts_node_type(node), \"preproc_function_def\") != 0 &amp;&amp;\n          ts_tree_cursor_goto_first_child(&amp;cursor)) {\n        // ^ do not recurse into preprocessor definitions, as we do not want\n        //   to replace preprocessor macros there\n      } else if (ts_tree_cursor_goto_next_sibling(&amp;cursor)) {\n        //\n      } else while (ts_tree_cursor_goto_parent(&amp;cursor) &amp;&amp;\n          !ts_tree_cursor_goto_next_sibling(&amp;cursor)) {\n        //\n      }\n    }\n    node = ts_tree_cursor_current_node(&amp;cursor);\n  } while (!ts_node_eq(node, root));\n\n  ts_tree_cursor_delete(&amp;cursor);\n  ts_tree_delete(tree);\n  ts_parser_reset(parser);\n  return in;\n}\n\nvoid CppParser::report(const std::filesystem::path&amp; filename,\n    const std::string&amp; in, TSTree* tree) {\n  TSNode root = ts_tree_root_node(tree);\n  TSNode node = root;\n  TSTreeCursor cursor = ts_tree_cursor_new(root);\n  do {\n    uint32_t k = ts_node_start_byte(node);\n    uint32_t l = ts_node_end_byte(node);\n    TSPoint from = ts_node_start_point(node);\n    if (ts_node_is_error(node)) {\n      std::cerr &lt;&lt; filename &lt;&lt; ':' &lt;&lt; (from.row + 1) &lt;&lt; ':' &lt;&lt; from.column &lt;&lt;\n          \": warning: parse error at '\" &lt;&lt;\n          in.substr(k, std::min(l - k, 40u)) &lt;&lt;\n          \"', but will continue\" &lt;&lt; std::endl;\n    }\n\n    /* next node */\n    if (strcmp(ts_node_type(node), \"preproc_def\") != 0 &amp;&amp;\n        strcmp(ts_node_type(node), \"preproc_function_def\") != 0 &amp;&amp;\n        ts_tree_cursor_goto_first_child(&amp;cursor)) {\n      // ^ do not recurse into preprocessor definitions\n    } else if (ts_tree_cursor_goto_next_sibling(&amp;cursor)) {\n      //\n    } else while (ts_tree_cursor_goto_parent(&amp;cursor) &amp;&amp;\n        !ts_tree_cursor_goto_next_sibling(&amp;cursor)) {\n      //\n    }\n    node = ts_tree_cursor_current_node(&amp;cursor);\n  } while (!ts_node_eq(node, root));\n  ts_tree_cursor_delete(&amp;cursor);\n}\n</code></pre>"},{"location":"demo/coverage/src/CppParser.hpp/","title":"CppParser.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n#include \"Entity.hpp\"\n\n/**\n * C++ source parser.\n * \n * @ingroup developer\n */\nclass CppParser {\npublic:\n  /**\n   * Constructor.\n   */\n  CppParser();\n\n  /**\n   * Destructor.\n   */\n  ~CppParser();\n\n  /**\n   * Parse C++ source.\n   * \n   * @param file C++ source file name.\n   * @param defines Macro definitions.\n   * @param[in,out] root Root entity.\n   */\n  void parse(const std::filesystem::path&amp; filename,\n      const std::unordered_map&lt;std::string,std::string&gt;&amp; defines,\n      Entity&amp; root);\n\nprivate:\n  /**\n   * Push onto the stack.\n   * \n   * @param entity Entity to push.\n   * @param start Start byte of range.\n   * @param end End byte of range.\n   */\n  void push(Entity&amp;&amp; entity, const uint32_t start, const uint32_t end);\n\n  /**\n   * Pop the stack down to the parent of an entity, according to its byte\n   * range.\n   * \n   * @param start Start byte of range.\n   * @param end End byte of range.\n   * \n   * @return The parent.\n   * \n   * If both @p start and @p end are zero, this is interpreting as popping the\n   * stack down to the root node and returning it.\n   */\n  Entity&amp; pop(const uint32_t start = 0, const uint32_t end = 0);\n\n  /**\n   * Preprocess C++ source, replacing preprocessor macros as defined in the\n   * config file and attempting to recover from any parse errors. This is\n   * silent and does not report uncorrectable errors, these are reported\n   * later.\n   *\n   * @param file C++ source file name.\n   * @param defines Macro definitions.\n   *\n   * @return Preprocessed source.\n   */\n  std::string preprocess(const std::filesystem::path&amp; file,\n      const std::unordered_map&lt;std::string,std::string&gt;&amp; defines);\n\n  /**\n   * Report errors after preprocessing.\n   * \n   * @param file C++ source file name.\n   * @param in Preprocessed source.\n   * @param tree Parse tree for file.\n   */\n  void report(const std::filesystem::path&amp; file, const std::string&amp; in,\n      TSTree* tree);\n\n  /**\n   * Stack of entities while parsing.\n   */\n  std::list&lt;Entity&gt; entities;\n\n  /**\n   * Stack of start bytes, corresponding to `entities`, while parsing.\n   */\n  std::list&lt;uint32_t&gt; starts;\n\n  /**\n   * Stack of end bytes, corresponding to `entities`, while parsing.\n   */\n  std::list&lt;uint32_t&gt; ends;\n\n  /**\n   * C++ parser.\n   */\n  TSParser* parser;\n\n  /**\n   * C++ entities query.\n   */\n  TSQuery* query;\n\n  /**\n   * C++ exclusions query.\n   */\n  TSQuery* query_exclude;\n\n  /**\n   * C++ inclusions query.\n   */\n  TSQuery* query_include;\n};\n</code></pre>"},{"location":"demo/coverage/src/Doc.cpp/","title":"Doc.cpp","text":"<pre><code>#include \"Doc.hpp\"\n#include \"DocTokenizer.hpp\"\n\nDoc::Doc(const std::string_view comment, const int init_indent) :\n    indent(init_indent),\n    hide(false) {\n  DocTokenizer tokenizer(comment);\n  DocToken token = tokenizer.next();\n  open = token;\n  if (open.type == OPEN_BEFORE || open.type == OPEN_AFTER) {\n    /* documentation comment, not just an ordinary comment */\n    token = tokenizer.next();\n    bool first = true;  // is this the first token in the comment?\n    if (!token.type) {\n      /* empty end-of-line comment, consider end of paragraph */\n      indent = std::max(indent - 4, 0);\n    } else while (token.type) {\n      if (token.type &amp; COMMAND) {\n        std::string_view command = token.substr(1);\n        if (command == \"param\" ||\n            command == \"param[in]\") {\n          docs.append(\"\\n:material-location-enter: `\");\n          docs.append(tokenizer.consume(WORD).str());\n          docs.append(\"`\\n:   \");\n          indent = 4;\n        } else if (command == \"param[out]\") {\n          docs.append(\"\\n:material-location-exit: `\");\n          docs.append(tokenizer.consume(WORD).str());\n          docs.append(\"`\\n:   \");\n          indent = 4;\n        } else if (command == \"param[in,out]\") {\n          docs.append(\"\\n:material-location-enter::material-location-exit: `\");\n          docs.append(tokenizer.consume(WORD).str());\n          docs.append(\"`\\n:   \");\n          indent = 4;\n        } else if (command == \"tparam\") {\n          docs.append(\"\\n:material-code-tags: `\");\n          docs.append(tokenizer.consume(WORD).str());\n          docs.append(\"`\\n:   \");\n          indent = 4;\n        } else if (command == \"p\") {\n          docs.append(\"`\");\n          docs.append(tokenizer.consume(WORD).str());\n          docs.append(\"`\");\n        } else if (command == \"return\") {\n          docs.append(\"\\n:material-keyboard-return: **Return**\\n:   \");\n        } else if (command == \"pre\") {\n          docs.append(\"\\n:material-check-circle-outline: **Pre-condition**\\n:   \");\n        } else if (command == \"post\") {\n          docs.append(\"\\n:material-check-circle-outline: **Post-condition**\\n:   \");\n        } else if (command == \"throw\") {\n          docs.append(\"\\n:material-alert-circle-outline: **Throw**\\n:   \");\n        } else if (command == \"see\") {\n          docs.append(\"\\n:material-eye-outline: **See**\\n:   \");\n        } else if (command == \"anchor\") {\n          docs.append(\"&lt;a name=\\\"\");\n          docs.append(tokenizer.consume(WORD).str());\n          docs.append(\"\\\"&gt;&lt;/a&gt;\");\n        } else if (command == \"note\" ||\n            command == \"abstract\" ||\n            command == \"info\" ||\n            command == \"tip\" ||\n            command == \"success\" ||\n            command == \"question\" ||\n            command == \"warning\" ||\n            command == \"failure\" ||\n            command == \"danger\" ||\n            command == \"bug\" ||\n            command == \"example\" ||\n            command == \"quote\") {\n          docs.append(\"\\n!!! \");\n          docs.append(command);\n          docs.append(\"\\n\");\n          indent += 4;\n        } else if (command == \"ingroup\") {\n          ingroup = tokenizer.consume(WORD).str();\n\n        /* legacy commands */\n        } else if (command == \"returns\" ||\n            command == \"result\") {\n          docs.append(\"\\n:material-location-exit: **Return**\\n:   \");\n        } else if (command == \"sa\") {\n          docs.append(\"\\n:material-eye-outline: **See**\\n:   \");\n        } else if (command == \"file\" ||\n            command == \"internal\") {\n          hide = true;\n        } else if (command == \"e\" ||\n            command == \"em\" ||\n            command == \"a\") {\n          docs.append(\"*\");\n          docs.append(tokenizer.consume(WORD).str());\n          docs.append(\"*\");\n        } else if (command == \"b\") {\n          docs.append(\"**\");\n          docs.append(tokenizer.consume(WORD).str());\n          docs.append(\"**\");\n        } else if (command == \"c\") {\n          docs.append(\"`\");\n          docs.append(tokenizer.consume(WORD).str());\n          docs.append(\"`\");\n        } else if (command == \"f$\") {\n          docs.append(\"$\");\n        } else if (command == \"f[\" ||\n            command == \"f]\") {\n          docs.append(\"$$\");\n        } else if (command == \"li\" ||\n            command == \"arg\") {\n          docs.append(\"  - \");\n        } else if (command == \"ref\") {\n          auto href = tokenizer.consume(WORD);\n          auto text = tokenizer.consume(WORD);\n          docs.append(\"[\");\n          docs.append(text.str());\n          docs.append(\"](#\");\n          docs.append(href.str());\n          docs.append(\")\");\n        } else if (command == \"code\" ||\n            command == \"endcode\" ||\n            command == \"verbatim\" ||\n            command == \"endverbatim\") {\n          docs.append(\"\\n```\");\n        } else if (command == \"attention\") {\n          docs.append(\"\\n!!! warning \\\"Attention\\\"\\n\");\n          indent += 4;\n          docs.append(indent, ' ');\n        } else if (command == \"todo\") {\n          docs.append(\"\\n!!! example \\\"To-do\\\"\\n\");\n          indent += 4;\n          docs.append(indent, ' ');\n        } else if (command == \"remark\") {\n          docs.append(\"\\n!!! quote \\\"Remark\\\"\\n\");\n          indent += 4;\n          docs.append(indent, ' ');\n        } else if (command == \"def\" ||\n            command == \"var\" ||\n            command == \"fn\" ||\n            command == \"class\" ||\n            command == \"struct\" ||\n            command == \"union\" ||\n            command == \"enum\" ||\n            command == \"typedef\" ||\n            command == \"namespace\" ||\n            command == \"interface\" ||\n            command == \"protocol\" ||\n            command == \"property\") {\n          /* ignore, including following name */\n          tokenizer.consume(WORD);\n        } else if (command == \"@\") {\n          docs.append(\"@\");\n        } else if (command == \"/\") {\n          docs.append(\"/\");\n        } else if (token.str().at(0) == '\\\\') {\n          /* unrecognized command starting with legacy backslash, could just\n           * be e.g. a LaTeX macro, output as is */\n          docs.append(token.str());\n        } else {\n          /* keep track of warnings and don't repeat them */\n          static std::unordered_set&lt;std::string&gt; warned;\n          if (warned.insert(std::string(command)).second) {\n            warn(\"unrecognized command: \" &lt;&lt; command);\n          }\n          docs.append(token.str());\n        }\n      } else if (token.type &amp; PARA) {\n        if (!first) {\n          docs.append(\"\\n\\n\");\n          indent = std::max(indent - 4, 0);\n        }\n      } else if (token.type &amp; LINE) {\n        if (!first) {\n          docs.append(\"\\n\");\n          docs.append(indent, ' ');\n        }\n      } else if (token.type &amp; CLOSE) {\n        //\n      } else {\n        docs.append(first*indent, ' ');  // indent on first token\n        docs.append(token.str());\n      }\n      token = tokenizer.next();\n      first = false;\n    }\n\n    /* trim whitespace from the end and add single new line */\n    while (docs.length() &gt; 0 &amp;&amp; std::isspace(docs.back())) {\n      docs.resize(docs.length() - 1);\n    }\n    docs.append(\"\\n\");\n  }\n}\n</code></pre>"},{"location":"demo/coverage/src/Doc.hpp/","title":"Doc.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n#include \"DocToken.hpp\"\n\n/**\n * Documentation of an entity.\n * \n * @ingroup developer\n */\nstruct Doc {\n  /**\n   * Constructor.\n   * \n   * @param comment Comment from which to populate documentation.\n   * @param init_indent Initial indent level.\n   */\n  Doc(const std::string_view comment, const int init_indent);\n\n  /**\n   * Content of the documentation.\n   */\n  std::string docs;\n\n  /**\n   * Group to which the entity belongs, obtained from @ingroup in the\n   * documentation comment.\n   */\n  std::string ingroup;\n\n  /**\n   * Opening token, used to determine the type of comment.\n   */\n  DocToken open;\n\n  /**\n   * Current indent level of the documentation comment for this entity. This\n   * is used for tracking indenting across multiple end-of-line comments, for\n   * example following a @@note command, each following line should be\n   * indented until the end of the paragraph.\n   */\n  int indent;\n\n  /**\n   * Hide the associated entity?\n   */\n  bool hide;\n};\n</code></pre>"},{"location":"demo/coverage/src/DocToken.cpp/","title":"DocToken.cpp","text":"<pre><code>#include \"DocToken.hpp\"\n\nDocToken::DocToken(const DocTokenType type, const std::string_view value) :\n    type(type),\n    value(value) {\n  //\n}\n\nstd::string_view DocToken::str() const {\n  /* std::string_view(first, last) ought to work with C++20 support, but\n   * using the below overload of the constructor extends support to some\n   * older compilers, such as gcc with gnu++2a support only, and MSVC 2022 */\n  return value;\n}\n\nstd::string_view DocToken::substr(size_t pos) const {\n  return value.substr(pos);\n}\n</code></pre>"},{"location":"demo/coverage/src/DocToken.hpp/","title":"DocToken.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n\n/**\n * Documentation comment token types. Closing delimiters must be one shift\n * left of their opening counterparts.\n *\n * @ingroup developer\n */\nenum DocTokenType : int {\n  NONE = 0,\n  OPEN_AFTER = 1 &lt;&lt; 1,   // opening sequence for doc comment after entity\n  OPEN_BEFORE = 1 &lt;&lt; 2,  // opening sequence for doc comment before entity\n  CLOSE = 1 &lt;&lt; 3,        // closing sequence for doc comment\n  COMMAND = 1 &lt;&lt; 4,\n  PARA = 1 &lt;&lt; 5,\n  LINE = 1 &lt;&lt; 6,\n  SENTENCE = 1 &lt;&lt; 7,\n  WHITESPACE = 1 &lt;&lt; 8,\n  WORD = 1 &lt;&lt; 9,\n  STAR = 1 &lt;&lt; 10,\n  SLASH = 1 &lt;&lt; 11,\n  ANY = ~0\n};\n\n/**\n * Documentation comment token patterns. Order is important, as a match to an\n * earlier pattern precludes a match to a later.\n *\n * @ingroup developer\n */\nstatic auto regexes = {\n  std::make_pair(OPEN_AFTER, std::regex(\"(?:/\\\\*\\\\*|/\\\\*!|///|//!)&lt;[ \\\\t]?\", regex_flags)),\n  std::make_pair(OPEN_BEFORE, std::regex(\"(?:/\\\\*\\\\*|/\\\\*!|///|//!)[ \\\\t]?\", regex_flags)),\n  std::make_pair(CLOSE, std::regex(\"\\\\*/\", regex_flags)),\n  std::make_pair(COMMAND, std::regex(\"[@\\\\\\\\](?:param(?:\\\\[(?:in|out|in,out)\\\\])?|\\\\w+|@|\\\\\\\\|/|f[\\\\$\\\\[\\\\]])\", regex_flags)),\n\n  /* the end of a paragraph is two new lines  */\n  std::make_pair(PARA, std::regex(\"(?:[ \\\\t]*\\\\n(?:[ \\\\t]*\\\\*(?!/))?[ \\\\t]?){2}\", regex_flags)),\n\n  /* the end of a line is one new line, as long as there is not an end of\n   * comment to come */\n  std::make_pair(LINE, std::regex(\"[ \\\\t]*\\\\n(?:[ \\\\t]*\\\\*(?!/))?[ \\\\t]?\", regex_flags)),\n\n  std::make_pair(SENTENCE, std::regex(\"[.!?]\", regex_flags)),\n  std::make_pair(WHITESPACE, std::regex(\"\\\\s+\", regex_flags)),\n  std::make_pair(WORD, std::regex(\"[^\\\\s\\\\*/]+\", regex_flags)),\n  std::make_pair(STAR, std::regex(\"\\\\*\", regex_flags)),\n  std::make_pair(SLASH, std::regex(\"/\", regex_flags))\n};\n\n/**\n * Token.\n * \n * @ingroup developer\n * \n * A token is only valid for the lifetime of the Tokenizer that produced it,\n * as it contains a reference to a substring of the source file.\n */\nstruct DocToken {\n  /**\n   * Constructor.\n   * \n   * @param type Token type.\n   * @param value Token value.\n   */\n  DocToken(const DocTokenType type = NONE,\n      std::string_view value = std::string_view());\n\n  /**\n   * Get token as string.\n   */\n  std::string_view str() const;\n\n  /**\n   * Get substring of the token as a string.\n   * \n   * @param pos Position of the first character.\n   */\n  std::string_view substr(size_t pos = 0) const;\n\n  /**\n   * Token type.\n   */\n  DocTokenType type;\n\n  /**\n   * Iterator to first character.\n   */\n  std::string_view value;\n};\n</code></pre>"},{"location":"demo/coverage/src/DocTokenizer.cpp/","title":"DocTokenizer.cpp","text":"<pre><code>#include \"DocTokenizer.hpp\"\n\nDocTokenizer::DocTokenizer(const std::string_view&amp; source) {\n  iter = source.cbegin();\n  end = source.cend();\n}\n\nDocToken DocTokenizer::next() {\n  DocToken token;\n  if (iter != end) {\n    for (auto&amp; [type, regex] : regexes) {\n      std::match_results&lt;std::string_view::const_iterator&gt; match;\n      if (std::regex_search(iter, end, match, regex,\n          std::regex_constants::match_continuous)) {\n        token.type = type;\n        token.value = std::string_view(iter, iter + match.length());\n        iter += match.length();\n        return token;\n      }\n    }\n    error(\"unrecognized token\");\n  }\n  return token;\n}\n\nDocToken DocTokenizer::consume(const int stop) {\n  DocToken token = next();\n  while (token.type &amp;&amp; !(token.type &amp; stop)) {\n    token = next();\n  }    \n  return token;\n}\n</code></pre>"},{"location":"demo/coverage/src/DocTokenizer.hpp/","title":"DocTokenizer.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n#include \"DocToken.hpp\"\n\n/**\n * Documentation comment tokenizer.\n * \n * @ingroup developer\n */\nclass DocTokenizer {\npublic:\n  /**\n   * Constructor.\n   * \n   * @param comment Comment to tokenize.\n   */\n  DocTokenizer(const std::string_view&amp; source);\n\n  /**\n   * Get the next token.\n   *\n   * @return Next token.\n   *\n   * The token is only valid for the lifetime of the DocTokenizer, as it\n   * contains a reference to a substring of the source file. If no tokens\n   * remain (i.e. the end of the file is reached), a token with a type of\n   * `NONE` is returned.\n   */\n  DocToken next();\n\n  /**\n   * Consume tokens until stopping criterion.\n   * \n   * @param stop Bitmask giving the token types on which to stop and return.\n   * \n   * @return Last token consumed.\n   * \n   * Tokens are consumed until one is encountered with a type in @p stop,\n   * which is then returned. If @p stop is `ANY` then the next token is\n   * returned.\n   */\n  DocToken consume(const int stop = ANY);\n\nprivate:\n  /**\n   * Iterator over source.\n   */\n  std::string_view::const_iterator iter;\n\n  /**\n   * End of source.\n   */\n  std::string_view::const_iterator end;\n};\n</code></pre>"},{"location":"demo/coverage/src/Driver.cpp/","title":"Driver.cpp","text":"<pre><code>#include \"Driver.hpp\"\n#include \"YAMLParser.hpp\"\n#include \"CppParser.hpp\"\n#include \"MarkdownGenerator.hpp\"\n#include \"GcovCounter.hpp\"\n#include \"JSONCounter.hpp\"\n#include \"JSONGenerator.hpp\"\n#include \"SourceWatcher.hpp\"\n\n#include &lt;thread&gt;\n\n/**\n * Contents of initial `doxide.yaml` file.\n * \n * @ingroup developer\n */\nstatic const char* init_doxide_yaml =\nR\"\"\"\"(title:\ndescription:\nfiles:\n  - \"*.hpp\"\n  - \"**/*.hpp\"\n  - \"*.h\"\n  - \"**/*.h\"\n)\"\"\"\";\n\n/**\n * Contents of initial `mkdocs.yaml` file.\n * \n * @ingroup developer\n */\nstatic const char* init_mkdocs_yaml =\nR\"\"\"\"(site_name:\nsite_description: \ntheme:\n  name: material\n  custom_dir: docs/overrides\n  features:\n    - navigation.indexes\n  palette:\n    # Palette toggle for light mode\n    - scheme: default\n      primary: red\n      accent: red\n      toggle:\n        icon: material/brightness-7 \n        name: Switch to dark mode\n\n    # Palette toggle for dark mode\n    - scheme: slate\n      primary: red\n      accent: red\n      toggle:\n        icon: material/brightness-4\n        name: Switch to light mode\n\nmarkdown_extensions:\n  - def_list\n  - attr_list\n  - admonition\n  - pymdownx.details\n  - pymdownx.superfences\n  - pymdownx.arithmatex:\n      generic: true\n  - pymdownx.emoji:\n      emoji_index: !!python/name:material.extensions.emoji.twemoji\n      emoji_generator: !!python/name:material.extensions.emoji.to_svg\nplugins:\n  - search\nextra_css:\n  - stylesheets/doxide.css\nextra_javascript:\n  - javascripts/mathjax.js\n  - https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\n  - https://cdn.jsdelivr.net/npm/tablesort@5.3.0/src/tablesort.min.js\n  - https://cdn.jsdelivr.net/npm/tablesort@5.3.0/src/sorts/tablesort.number.js\n  - javascripts/tablesort.js\n)\"\"\"\";\n\n/**\n * Contents of initial `docs/javascripts/mathjax.js` file.\n * \n * @ingroup developer\n */\nstatic const char* init_docs_javascripts_mathjax_js =\nR\"\"\"\"(window.MathJax = {\n  tex: {\n    inlineMath: [[\"\\\\(\", \"\\\\)\"]],\n    displayMath: [[\"\\\\[\", \"\\\\]\"]],\n    processEscapes: true,\n    processEnvironments: true\n  },\n  options: {\n    ignoreHtmlClass: \".*|\",\n    processHtmlClass: \"arithmatex\"\n  }\n};\n\ndocument$.subscribe(() =&gt; { \n  MathJax.typesetPromise()\n})\n)\"\"\"\";\n\n/**\n * Contents of initial `docs/javascripts/tablesort.js` file.\n * \n * @ingroup developer\n */\nstatic const char* init_docs_javascripts_tablesort_js =\nR\"\"\"\"(document$.subscribe(function() {\n  var tables = document.querySelectorAll(\"article table:not([class])\")\n  tables.forEach(function(table) {\n    new Tablesort(table)\n  })\n})\n)\"\"\"\";\n\n/**\n * Contents of initial `docs/stylesheets/doxide.css` file.\n * \n * @ingroup developer\n */\nstatic const char* init_docs_stylesheets_doxide_css =\nR\"\"\"\"(:root {\n  --md-admonition-icon--variable: url('data:image/svg+xml;charset=utf-8,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"&gt;&lt;path d=\"M20.41 3c1.39 2.71 1.94 5.84 1.59 9-.2 3.16-1.3 6.29-3.17 9l-1.53-1c1.61-2.43 2.55-5.2 2.7-8 .34-2.8-.11-5.57-1.3-8l1.71-1M5.17 3 6.7 4C5.09 6.43 4.15 9.2 4 12c-.34 2.8.12 5.57 1.3 8l-1.69 1c-1.4-2.71-1.96-5.83-1.61-9 .2-3.16 1.3-6.29 3.17-9m6.91 7.68 2.32-3.23h2.53l-3.78 5 2.2 4.92h-2.26L11.71 14l-2.43 3.33H6.76l3.9-5.12-2.13-4.76h2.27l1.28 3.23Z\"/&gt;&lt;/svg&gt;');\n  --md-admonition-icon--function: url('data:image/svg+xml;charset=utf-8,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"&gt;&lt;path d=\"M15.6 5.29c-1.1-.1-2.07.71-2.17 1.82L13.18 10H16v2h-3l-.44 5.07a3.986 3.986 0 0 1-4.33 3.63 4.007 4.007 0 0 1-3.06-1.87l1.5-1.5c.24.74.9 1.31 1.73 1.38 1.1.1 2.07-.71 2.17-1.82L11 12H8v-2h3.17l.27-3.07c.19-2.2 2.13-3.83 4.33-3.63 1.31.11 2.41.84 3.06 1.87l-1.5 1.5c-.24-.74-.9-1.31-1.73-1.38Z\"/&gt;&lt;/svg&gt;');\n  --md-admonition-icon--typedef: url('data:image/svg+xml;charset=utf-8,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"&gt;&lt;path d=\"M 13.43 7.11 L 13.18 10 H 17 V 12 H 13 L 12.56 17.07 A 1 1 0 0 0 15.287 17.261 L 17.028 17.48 A 1 1 0 0 1 10.57 16.89 L 11 12 H 8 V 10 H 11.17 L 11.44 6.93 Z\"/&gt;&lt;/svg&gt;');\n  --md-admonition-icon--concept: url('data:image/svg+xml;charset=utf-8,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"&gt;&lt;path d=\"M3.75 3.5a.25.25 0 0 0-.25.25v2.062a.75.75 0 1 1-1.5 0V3.75C2 2.783 2.783 2 3.75 2h2.062a.75.75 0 1 1 0 1.5Zm13.688-.75a.75.75 0 0 1 .75-.75h2.062c.966 0 1.75.783 1.75 1.75v2.062a.75.75 0 1 1-1.5 0V3.75a.25.25 0 0 0-.25-.25h-2.062a.75.75 0 0 1-.75-.75ZM2.75 17.438a.75.75 0 0 1 .75.75v2.062c0 .138.112.25.25.25h2.062a.75.75 0 1 1 0 1.5H3.75A1.75 1.75 0 0 1 2 20.25v-2.062a.75.75 0 0 1 .75-.75Zm18.5 0a.75.75 0 0 1 .75.75v2.062A1.75 1.75 0 0 1 20.25 22h-2.062a.75.75 0 1 1 0-1.5h2.062a.25.25 0 0 0 .25-.25v-2.062a.75.75 0 0 1 .75-.75Zm-18.5-8.25a.75.75 0 0 1 .75.75v4.124a.75.75 0 1 1-1.5 0V9.938a.75.75 0 0 1 .75-.75ZM9.188 2.75a.75.75 0 0 1 .75-.75h4.124a.75.75 0 1 1 0 1.5H9.938a.75.75 0 0 1-.75-.75Zm0 18.5a.75.75 0 0 1 .75-.75h4.124a.75.75 0 1 1 0 1.5H9.938a.75.75 0 0 1-.75-.75ZM21.25 9.188a.75.75 0 0 1 .75.75v4.124a.75.75 0 1 1-1.5 0V9.938a.75.75 0 0 1 .75-.75ZM3.75 8.25a.75.75 0 0 1 .75-.75h2a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1-.75-.75Zm5.5 0A.75.75 0 0 1 10 7.5h2A.75.75 0 0 1 12 9h-2a.75.75 0 0 1-.75-.75Zm-1-4.5A.75.75 0 0 1 9 4.5v2a.75.75 0 0 1-1.5 0v-2a.75.75 0 0 1 .75-.75Zm0 5.5A.75.75 0 0 1 9 10v2a.75.75 0 0 1-1.5 0v-2a.75.75 0 0 1 .75-.75Zm0 4.75a.75.75 0 0 1 .75.75v4a.75.75 0 0 1-1.5 0v-4a.75.75 0 0 1 .75-.75ZM14 8.25a.75.75 0 0 1 .75-.75h4a.75.75 0 0 1 0 1.5h-4a.75.75 0 0 1-.75-.75Z\"/&gt;&lt;/svg&gt;');\n  --md-admonition-icon--macro: url('data:image/svg+xml;charset=utf-8,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"&gt;&lt;path d=\"m5.41 21 .71-4h-4l.35-2h4l1.06-6h-4l.35-2h4l.71-4h2l-.71 4h6l.71-4h2l-.71 4h4l-.35 2h-4l-1.06 6h4l-.35 2h-4l-.71 4h-2l.71-4h-6l-.71 4h-2M9.53 9l-1.06 6h6l1.06-6h-6Z\"/&gt;&lt;/svg&gt;');\n}\n\n.md-typeset .admonition.variable, .md-typeset details.variable,\n.md-typeset .admonition.function, .md-typeset details.function,\n.md-typeset .admonition.typedef, .md-typeset details.typedef,\n.md-typeset .admonition.concept, .md-typeset details.concept,\n.md-typeset .admonition.macro, .md-typeset details.macro {\n  border-color: var(--md-default-fg-color--lighter);\n}\n\n.md-typeset .variable &gt; .admonition-title, .md-typeset .variable &gt; summary,\n.md-typeset .function &gt; .admonition-title, .md-typeset .function &gt; summary,\n.md-typeset .typedef &gt; .admonition-title, .md-typeset .typedef &gt; summary,\n.md-typeset .concept &gt; .admonition-title, .md-typeset .concept &gt; summary,\n.md-typeset .macro &gt; .admonition-title, .md-typeset .macro &gt; summary {\n  background-color: var(--md-default-bg-color);\n}\n\n.md-typeset .variable &gt; .admonition-title::before,\n.md-typeset .variable &gt; summary::before {\n  background-color: var(--md-default-fg-color--light);\n  -webkit-mask-image: var(--md-admonition-icon--variable);\n          mask-image: var(--md-admonition-icon--variable);\n}\n\n.md-typeset .function &gt; .admonition-title::before,\n.md-typeset .function &gt; summary::before {\n  background-color: var(--md-default-fg-color--light);\n  -webkit-mask-image: var(--md-admonition-icon--function);\n          mask-image: var(--md-admonition-icon--function);\n}\n\n.md-typeset .typedef &gt; .admonition-title::before,\n.md-typeset .typedef &gt; summary::before {\n  background-color: var(--md-default-fg-color--light);\n  -webkit-mask-image: var(--md-admonition-icon--typedef);\n          mask-image: var(--md-admonition-icon--typedef);\n}\n\n.md-typeset .concept &gt; .admonition-title::before,\n.md-typeset .concept &gt; summary::before {\n  background-color: var(--md-default-fg-color--light);\n  -webkit-mask-image: var(--md-admonition-icon--concept);\n          mask-image: var(--md-admonition-icon--concept);\n}\n\n.md-typeset .macro &gt; .admonition-title::before,\n.md-typeset .macro &gt; summary::before {\n  background-color: var(--md-default-fg-color--light);\n  -webkit-mask-image: var(--md-admonition-icon--macro);\n          mask-image: var(--md-admonition-icon--macro);\n}\n)\"\"\"\";\n\n/**\n * Contents of initial `docs/overrides/partials/copyright.html` file.\n * \n * @ingroup developer\n */\nstatic const char* init_docs_overrides_partials_copyright_html =\nR\"\"\"\"(&lt;div class=\"md-copyright\"&gt;\n  {% if config.copyright %}\n    &lt;div class=\"md-copyright__highlight\"&gt;\n      {{ config.copyright }}\n    &lt;/div&gt;\n  {% endif %}\n  {% if not config.extra.generator == false %}\n    Made with\n    &lt;a href=\"https://doxide.org\" target=\"_blank\" rel=\"noopener\"&gt;\n      Doxide\n    &lt;/a&gt;\n    and\n    &lt;a href=\"https://squidfunk.github.io/mkdocs-material/\" target=\"_blank\" rel=\"noopener\"&gt;\n      Material for MkDocs\n    &lt;/a&gt;\n  {% endif %}\n&lt;/div&gt;\n)\"\"\"\";\n\nDriver::Driver() :\n    title(\"Untitled\"),\n    output(\"docs\") {\n  //\n}\n\nvoid Driver::init() {\n  std::string doxide_yaml = init_doxide_yaml;\n  std::string mkdocs_yaml = init_mkdocs_yaml;\n\n  doxide_yaml = std::regex_replace(doxide_yaml, std::regex(\"title:\"),\n      \"title: \" + title);\n  doxide_yaml = std::regex_replace(doxide_yaml, std::regex(\"description:\"),\n      \"description: \" + description);\n\n  mkdocs_yaml = std::regex_replace(mkdocs_yaml, std::regex(\"site_name:\"),\n      \"site_name: \" + title);\n  mkdocs_yaml = std::regex_replace(mkdocs_yaml, std::regex(\"site_description:\"),\n      \"site_description: \" + description);\n\n  write_file_prompt(doxide_yaml, \"doxide.yaml\");\n  write_file_prompt(mkdocs_yaml, \"mkdocs.yaml\");\n  write_file_prompt(init_docs_javascripts_mathjax_js, \"docs/javascripts/mathjax.js\");\n  write_file_prompt(init_docs_javascripts_tablesort_js, \"docs/javascripts/tablesort.js\");\n  write_file_prompt(init_docs_stylesheets_doxide_css, \"docs/stylesheets/doxide.css\");\n  write_file_prompt(init_docs_overrides_partials_copyright_html, \"docs/overrides/partials/copyright.html\");\n}\n\nvoid Driver::build() {\n  config();\n  parse();\n  count();\n\n  MarkdownGenerator generator(output);\n  generator.generate(root, !coverage.empty());\n  generator.clean();\n}\n\nvoid Driver::watch() {\n\n  build();\n\n  std::cout &lt;&lt; \"Start watching\" &lt;&lt; std::endl;\n\n  SourceWatcher config_watcher = SourceWatcher(config_file.string());\n  SourceWatcher watcher = SourceWatcher(files_patterns);\n\n  CppParser parser;\n\n  for (;;){\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    if (config_watcher.changed()){\n      std::cout &lt;&lt; std::endl &lt;&lt; \"Detected configuration file change.\" &lt;&lt; std::endl;\n      std::cout &lt;&lt; \"Rebuilding documentation...\" &lt;&lt; std::endl;\n\n      root.clear();\n      build();\n\n      config_watcher = SourceWatcher(config_file.string());\n      watcher = SourceWatcher(files_patterns);\n\n      std::cout &lt;&lt; \"Done\" &lt;&lt; std::endl;\n\n      continue;\n    }\n\n    auto [added_files, changed_files, deleted_files] = watcher.diff();\n    if (!added_files.empty() || !changed_files.empty() || !deleted_files.empty()){\n\n      std::cout &lt;&lt; std::endl &lt;&lt; \"Detected changes:\" &lt;&lt; std::endl;\n      for (const auto&amp; filename: added_files) {\n        std::cout &lt;&lt; \"Added:   \" &lt;&lt; filename &lt;&lt; std::endl;\n      }\n      for (const auto&amp; filename: changed_files) {\n        std::cout &lt;&lt; \"Changed: \" &lt;&lt; filename &lt;&lt; std::endl;\n      }\n      for (const auto&amp; filename: deleted_files) {\n        std::cout &lt;&lt; \"Deleted: \" &lt;&lt; filename &lt;&lt; std::endl;\n      }\n      std::cout &lt;&lt; \"Rebuilding documentation...\" &lt;&lt; std::endl;\n\n      filenames = watcher.filenames();\n\n      for (const auto&amp; filename: deleted_files) {\n        root.delete_by_predicate([filename](const Entity&amp; e) {return e.path == filename; });\n      }\n      for (const auto&amp; filename: changed_files) {\n        root.delete_by_predicate([filename](const Entity&amp; e) {return e.path == filename; });\n      }\n\n      for (const auto&amp; filename: changed_files) {\n        parser.parse(filename, defines, root);\n      }\n      for (const auto&amp; filename: added_files) {\n        parser.parse(filename, defines, root);\n      }\n\n      count();\n\n      MarkdownGenerator generator(output);\n      generator.generate(root, !coverage.empty());\n      generator.clean();\n\n      std::cout &lt;&lt; \"Done\" &lt;&lt; std::endl;\n    }\n  }\n}\n\nvoid Driver::cover() {\n  config();\n  parse();\n  count();\n\n  JSONGenerator generator;\n  generator.generate(root);\n}\n\nvoid Driver::clean() {\n  config();\n\n  /* can use MarkdownGenerator::clean() for this just by not calling\n   * generate() first; this will remove all files with `generator: doxide` in\n   * their YAML frontmatter */\n  MarkdownGenerator generator(output);\n  generator.clean();\n}\n\nvoid Driver::config() {\n  /* find the configuration file */\n  if (std::filesystem::exists(\"doxide.yaml\")) {\n    config_file = \"doxide.yaml\";\n  } else if (std::filesystem::exists(\"doxide.yml\")) {\n    config_file = \"doxide.yml\";\n  } else if (std::filesystem::exists(\"doxide.json\")) {\n    config_file = \"doxide.json\";\n  } else {\n    error(\"no configuration file found; create a doxide.yaml file to configure Doxide.\");\n  }\n\n  /* parse build configuration file */\n  YAMLParser parser;\n  YAMLNode yaml = parser.parse(config_file);\n\n  if (yaml.has(\"title\")) {\n    if (yaml.isValue(\"title\")) {\n      title = yaml.value(\"title\");\n    } else {\n      warn(\"'title' must be a value in configuration.\");\n    }\n  }\n  if (yaml.has(\"description\")) {\n    if (yaml.isValue(\"description\")) {\n      description = yaml.value(\"description\");\n    } else {\n      warn(\"'description' must be a value in configuration.\");\n    }\n  }\n  if (yaml.has(\"coverage\")) {\n    if (yaml.isValue(\"coverage\")) {\n      coverage = yaml.value(\"coverage\");\n    } else {\n      warn(\"'coverage' must be a value in configuration.\");\n    }\n  }\n  if (yaml.has(\"output\")) {\n    if (yaml.isValue(\"output\")) {\n      output = yaml.value(\"output\");\n    } else {\n      warn(\"'output' must be a value in configuration.\");\n    }\n  }\n  if (yaml.has(\"defines\")) {\n    if (yaml.isMapping(\"defines\")) {\n      const auto&amp; map = yaml.mapping(\"defines\");\n      for (auto&amp; [key, value] : map) {\n        if (value-&gt;isValue()) {\n          defines[key] = value-&gt;value();\n        }\n      }\n    } else {\n      warn(\"'defines' must be a mapping in configuration.\");\n    }\n  }\n\n  /* expand file patterns in file list */\n  filenames.clear();\n  if (yaml.isSequence(\"files\")) {\n    for (auto&amp; node : yaml.sequence(\"files\")) {\n      if (node-&gt;isValue()) {\n        auto&amp; pattern = node-&gt;value();\n        files_patterns.push_back(pattern);\n        auto paths = glob::rglob(pattern);\n        if (paths.empty()) {\n          /* print warning if pattern does not contain a wildcard '*' */\n          if (pattern.find('*') == std::string::npos) {\n            warn(\"no file matching '\" + pattern + \"' in configuration.\");\n          }\n        } else for (auto path : paths) {\n          auto result = filenames.insert(path.string());\n          if (!result.second) {\n            warn(\"file \" &lt;&lt; path &lt;&lt; \" appears more than once in configuration.\");\n          }\n        }\n      }\n    }\n  }\n\n  /* initialize root entity */\n  groups(yaml, root);\n  root.title = title;\n  root.docs = description;\n}\n\nvoid Driver::parse() {\n  CppParser parser;\n  for (const auto&amp; filename: filenames) {\n    parser.parse(filename, defines, root);\n  }\n}\n\nvoid Driver::count() {\n  if (!coverage.empty()) {\n    try {\n      auto ext = coverage.extension();\n      if (ext == \".gcov\") {\n        GcovCounter counter;\n        counter.count(coverage, root);\n      } else if (ext == \".json\") {\n        JSONCounter counter;\n        counter.count(coverage, root);\n      } else {\n        throw std::runtime_error(\"unrecognized file extension on \" +\n            coverage.string());\n      }\n    } catch (const std::runtime_error&amp; e) {\n      warn(e.what() &lt;&lt; \", coverage will be reported as zero\");\n    }\n  }\n}\n\nvoid Driver::groups(YAMLNode&amp; parentNode, Entity&amp; parentEntity) {\n  if (parentNode.isSequence(\"groups\")) {\n    for (auto&amp; node : parentNode.sequence(\"groups\")) {\n      Entity entity;\n      entity.type = EntityType::GROUP;\n      entity.visible = true;\n      if (node-&gt;isValue(\"name\")) {\n        entity.name = node-&gt;value(\"name\");\n        if (node-&gt;isValue(\"title\")) {\n          entity.title = node-&gt;value(\"title\");\n        }\n        if (node-&gt;isValue(\"description\")) {\n          entity.docs = node-&gt;value(\"description\");\n        }\n      } else {\n        warn(\"a group is missing a name in the configuration file.\")\n      }\n      groups(*node, entity);\n      parentEntity.add(std::move(entity));\n    }\n  }\n}\n</code></pre>"},{"location":"demo/coverage/src/Driver.hpp/","title":"Driver.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n#include \"YAMLNode.hpp\"\n#include \"Entity.hpp\"\n\n/**\n * Driver for running commands\n * \n * @ingroup developer\n */\nclass Driver {\npublic:\n  /**\n   * Constructor.\n   */\n  Driver();\n\n  /**\n   * Create a new configuration file.\n   */\n  void init();\n\n  /**\n   * Build documentation.\n   */\n  void build();\n\n  /**\n   * Watch and build documentation on changes.\n   */\n  void watch();\n\n  /**\n   * Output line coverage information.\n   */\n  void cover();\n\n  /**\n   * Clean documentation.\n   */\n  void clean();\n\n  /**\n   * Title.\n   */\n  std::string title;\n\n  /**\n   * Description.\n   */\n  std::string description;\n\n  /**\n   * Coverage file.\n   */\n  std::filesystem::path coverage;\n\n  /**\n   * Output directory.\n   */\n  std::filesystem::path output;\n\nprivate:\n  /**\n   * Read in the configuration file.\n   */\n  void config();\n\n  /**\n   * Parse files.\n   */\n  void parse();\n\n  /**\n   * Count line coverage.\n   */\n  void count();\n\n  /**\n   * Recursively read groups from the configuration file.\n   */\n  static void groups(YAMLNode&amp; parentNode, Entity&amp; parentEntity);\n\n  /**\n   * Root entity.\n   */\n  Entity root;\n\n  /**\n   * Configuration file path.\n   */\n  std::filesystem::path config_file;\n\n  /**\n   * Files patterns.\n   */\n  std::list&lt;std::string&gt; files_patterns;\n\n  /**\n   * Macro definitions.\n   */\n  std::unordered_map&lt;std::string,std::string&gt; defines;\n\n  /**\n   * Files.\n   */\n  std::unordered_set&lt;std::filesystem::path&gt; filenames;\n};\n</code></pre>"},{"location":"demo/coverage/src/Entity.cpp/","title":"Entity.cpp","text":"<pre><code>#include \"Entity.hpp\"\n\nEntity::Entity() :\n   start_line(0),\n   end_line(0),\n   lines_included(0),\n   lines_covered(0),\n   type(EntityType::ROOT),\n   visible(false),\n   hide(false) {\n  //\n}\n\nvoid Entity::add(Entity&amp;&amp; o) {\n  if (o.type == EntityType::NAMESPACE &amp;&amp; !o.ingroup.empty()) {\n    warn(\"namespace cannot have @ingroup, ignoring\");\n    o.ingroup.clear();\n  }\n  if (!o.ingroup.empty()) {\n    if (addToGroup(std::move(o))) {\n      return;\n    } else {\n      /* keep track of warnings and don't repeat them */\n      static std::unordered_set&lt;std::string&gt; warned;\n      if (warned.insert(o.ingroup).second) {\n        warn(\"unrecognized group \" &lt;&lt; o.ingroup &lt;&lt;\n            \", groups must be defined in config file, ignoring @ingroup\");\n      }\n    }\n  }\n  addToThis(std::move(o));\n}\n\nbool Entity::addToGroup(Entity&amp;&amp; o) {\n  /* search for immediate child of given name */\n  auto iter = std::find_if(groups.begin(), groups.end(),\n      [&amp;o](const Entity&amp; g) {\n        return g.name == o.ingroup;\n      });\n  if (iter != groups.end()) {\n    iter-&gt;addToThis(std::move(o));\n    return true;\n  }\n\n  /* search recursively for descendent of given name */\n  for (auto&amp; g : groups) {\n    if (g.addToGroup(std::move(o))) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid Entity::addToThis(Entity&amp;&amp; o) {\n  if (o.type == EntityType::NAMESPACE) {\n    auto iter = std::find_if(namespaces.begin(), namespaces.end(),\n        [&amp;o](const Entity&amp; ns) {\n          return ns.name == o.name;\n        });\n    if (iter == namespaces.end()) {\n      namespaces.push_back(std::move(o));\n    } else {\n      iter-&gt;merge(std::move(o));\n    }\n  } else if (o.type == EntityType::GROUP) {\n    groups.push_back(std::move(o));\n  } else if (o.type == EntityType::TYPE) {\n    types.push_back(std::move(o));\n  } else if (o.type == EntityType::TYPEDEF) {\n    typedefs.push_back(std::move(o));\n  } else if (o.type == EntityType::CONCEPT) {\n    concepts.push_back(std::move(o));\n  } else if (o.type == EntityType::VARIABLE) {\n    variables.push_back(std::move(o));\n  } else if (o.type == EntityType::FUNCTION) {\n    functions.push_back(std::move(o));\n  } else if (o.type == EntityType::OPERATOR) {\n    operators.push_back(std::move(o));\n  } else if (o.type == EntityType::ENUMERATOR) {\n    enums.push_back(std::move(o));\n  } else if (o.type == EntityType::MACRO) {\n    macros.push_back(std::move(o));\n  } else if (o.type == EntityType::TEMPLATE) {\n    // ignore, likely a parse error within the template declaration\n  } else if (o.type == EntityType::FILE || o.type == EntityType::DIR) {\n    /* maintain directory structure */\n    std::filesystem::path path = o.path, subdir;\n    path = path.parent_path();\n    Entity* e = this;\n    e-&gt;lines_included += o.lines_included;\n    e-&gt;lines_covered += o.lines_covered;\n    for (auto iter = path.begin(); iter != path.end(); ++iter) {\n      auto single = iter-&gt;string();\n      auto found = std::find_if(e-&gt;dirs.begin(), e-&gt;dirs.end(),\n          [&amp;single](auto&amp; s) { return s.name == single; });\n      subdir /= single;\n      if (found == e-&gt;dirs.end()) {\n        /* add subdirectory */\n        e = &amp;e-&gt;dirs.emplace_back();\n        e-&gt;type = EntityType::DIR;\n        e-&gt;visible = true;\n        e-&gt;name = single;\n        e-&gt;path = subdir.string();\n      } else {\n        e = &amp;(*found);\n      }\n      e-&gt;lines_included += o.lines_included;\n      e-&gt;lines_covered += o.lines_covered;\n    }\n    e-&gt;files.push_back(std::move(o));\n  } else {\n    warn(\"unrecognized entity type, ignoring\");\n  }\n  visible = visible || o.visible;\n}\n\nvoid Entity::merge(Entity&amp;&amp; o) {\n  /* add namespaces via the merging logic of addToThis() */\n  std::for_each(o.namespaces.begin(), o.namespaces.end(),\n      [this](Entity&amp; o) {\n        this-&gt;addToThis(std::move(o));\n      });\n\n  groups.splice(groups.end(), std::move(o.groups));\n  types.splice(types.end(), std::move(o.types));\n  typedefs.splice(types.end(), std::move(o.typedefs));\n  concepts.splice(concepts.end(), std::move(o.concepts));\n  variables.splice(variables.end(), std::move(o.variables));\n  functions.splice(functions.end(), std::move(o.functions));\n  operators.splice(operators.end(), std::move(o.operators));\n  macros.splice(macros.end(), std::move(o.macros));\n  enums.splice(enums.end(), std::move(o.enums));\n  dirs.splice(dirs.end(), std::move(o.dirs));\n  files.splice(files.end(), std::move(o.files));\n\n  /* merge line counts, recalling that -1 indicates excluded lines, so cannot\n   * simply add the two vectors */\n  end_line = uint32_t(std::max(line_counts.size(), o.line_counts.size()));\n  line_counts.resize(end_line, -1);\n  lines_included = 0;\n  lines_covered = 0;\n  for (uint32_t i = 0; i &lt; end_line; ++i) {\n    int count = (i &lt; o.line_counts.size()) ? o.line_counts[i] : -1;\n    if (line_counts[i] &gt;= 0 || count &gt;= 0) {\n      line_counts[i] = std::max(line_counts[i], 0) + std::max(count, 0);\n      ++lines_included;\n      if (line_counts[i] &gt; 0) {\n        ++lines_covered;\n      }\n    }\n  }\n\n  if (ingroup.empty()) {\n    ingroup = std::move(o.ingroup);\n  }\n  name = o.name;\n  if (type == EntityType::TEMPLATE) {\n    decl += \" \";\n    decl += std::move(o.decl);\n  }\n  docs += std::move(o.docs);\n  brief += std::move(o.brief);\n  type = o.type;\n  hide = hide || o.hide;\n  visible = visible || o.visible;\n}\n\nbool Entity::exists(std::filesystem::path&amp; path) const {\n  auto parent_path = path.parent_path();\n  auto e = this;\n  for (auto iter = parent_path.begin(); iter != parent_path.end(); ++iter) {\n    auto single = iter-&gt;string();\n    auto found = std::find_if(e-&gt;dirs.begin(), e-&gt;dirs.end(),\n        [&amp;single](auto&amp; s) { return s.name == single; });\n    if (found == e-&gt;dirs.end()) {\n      return false;\n    } else {\n      e = &amp;(*found);\n    }\n  }\n\n  auto file = path.filename().string();\n  auto found = std::find_if(e-&gt;files.begin(), e-&gt;files.end(),\n      [&amp;file](auto&amp; s) { return s.name == file; });\n  return found != e-&gt;files.end();\n}\n\nstd::list&lt;Entity*&gt; Entity::get(std::filesystem::path&amp; path) {\n  auto parent_path = path.parent_path();\n  std::list&lt;Entity*&gt; r;\n  auto e = this;\n  r.push_back(e);\n  for (auto iter = parent_path.begin(); iter != parent_path.end(); ++iter) {\n    auto single = iter-&gt;string();\n    auto found = std::find_if(e-&gt;dirs.begin(), e-&gt;dirs.end(),\n        [&amp;single](auto&amp; s) { return s.name == single; });\n    assert(found != e-&gt;dirs.end());\n    e = &amp;(*found);\n    r.push_back(e);\n  }\n\n  auto file = path.filename().string();\n  auto found = std::find_if(e-&gt;files.begin(), e-&gt;files.end(),\n      [&amp;file](auto&amp; s) { return s.name == file; });\n  assert(found != e-&gt;files.end());\n  e = &amp;(*found);\n  r.push_back(e);\n\n  return r;\n}\n\nvoid Entity::clear() {\n  *this = Entity();\n}\n\nvoid Entity::delete_by_predicate(std::function&lt;bool(const Entity&amp;)&gt; p){\n    std::erase_if(namespaces, p);\n    std::erase_if(groups, p);\n    std::erase_if(types, p);\n    std::erase_if(concepts, p);\n    std::erase_if(variables, p);\n    std::erase_if(functions, p);\n    std::erase_if(operators, p);\n    std::erase_if(enums, p);\n    std::erase_if(macros, p);\n    std::erase_if(dirs, p);\n    std::erase_if(files, p);\n\n    auto r = [p](Entity&amp; e){ e.delete_by_predicate(p); };\n        std::for_each(namespaces.begin(), namespaces.end(), r);\n    std::for_each(groups.begin(), groups.end(), r);\n    std::for_each(types.begin(), types.end(), r);\n    std::for_each(concepts.begin(), concepts.end(), r);\n        std::for_each(variables.begin(), variables.end(), r);\n        std::for_each(functions.begin(), functions.end(), r);\n        std::for_each(operators.begin(), operators.end(), r);\n    std::for_each(enums.begin(), enums.end(), r);\n    std::for_each(macros.begin(), macros.end(), r);\n    std::for_each(dirs.begin(), dirs.end(), r);\n    std::for_each(files.begin(), files.end(), r);\n}\n</code></pre>"},{"location":"demo/coverage/src/Entity.hpp/","title":"Entity.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n\n#include &lt;filesystem&gt;\n\n/**\n * Entity types.\n * \n * @ingroup developer\n */\nenum class EntityType {\n  ROOT,\n  NAMESPACE,\n  TEMPLATE,\n  GROUP,\n  TYPE,\n  TYPEDEF,\n  CONCEPT,\n  VARIABLE,\n  FUNCTION,\n  OPERATOR,\n  ENUMERATOR,\n  MACRO,\n  DIR,\n  FILE\n};\n\n/**\n * Entity in a C++ source file, e.g. variable, function, class, etc.\n * \n * @ingroup developer\n */\nstruct Entity {\n  /**\n   * Child entities are stored in a list, rather than map by name, to preserve\n   * declaration order. They may be sorted by name on output.\n   */\n  using list_type = std::list&lt;Entity&gt;;\n\n  /**\n   * Constructor.\n  */\n  Entity();\n\n  /**\n   * Add child entity.\n   * \n   * @param o Child entity.\n   * \n   * If the child has `ingroup` set, then will search for and add to that\n   * group instead.\n   */\n  void add(Entity&amp;&amp; o);\n\n  /**\n   * Merge the children of another entity into this one.\n   * \n   * @param o Other entity.\n   */\n  void merge(Entity&amp;&amp; o);\n\n  /**\n   * Does a file exist of the given name?\n   * \n   * @param path File path.\n   */\n  bool exists(std::filesystem::path&amp; path) const;\n\n  /**\n   * Get a file of the given name. The file must exist (use `exists()`).\n   *\n   * @param path File path.\n   *\n   * @return List of entities giving the full path to the file. The last\n   * entity represents the file itself, the preceding entities its\n   * subdirectories.\n   */\n  std::list&lt;Entity*&gt; get(std::filesystem::path&amp; path);\n\n  /**\n   * Clear the entity.\n   */\n  void clear();\n\n  /**\n   * Recursively delete all child entities that satisfy the predicate.\n   *\n   * @param p Predicate.\n   */\n  void delete_by_predicate(std::function&lt;bool(const Entity&amp;)&gt; p);\n\n  /**\n   * Child namespaces.\n   */\n  list_type namespaces;\n\n  /**\n   * Child groups.\n   */\n  list_type groups;\n\n  /**\n   * Child types.\n   */\n  list_type types;\n\n  /**\n   * Child typedefs and type aliases.\n   */\n  list_type typedefs;\n\n  /**\n   * Child concepts.\n   */\n  list_type concepts;\n\n  /**\n   * Child variables.\n   */\n  list_type variables;\n\n  /**\n   * Child functions.\n   */\n  list_type functions;\n\n  /**\n   * Child operators.\n   */\n  list_type operators;\n\n  /**\n   * Child enumerators.\n   */\n  list_type enums;\n\n  /**\n   * Child macros.\n   */\n  list_type macros;\n\n  /**\n   * Child directories.\n   */\n  list_type dirs;\n\n  /**\n   * Child files.\n   */\n  list_type files;\n\n  /**\n   * Entity name (e.g. name of variable, function, class). For a file or\n   * directory this is the full path.\n   */\n  std::string name;\n\n  /**\n   * Entity declaration (e.g. function signature). For a file this is its full\n   * contents.\n   */\n  std::string decl;\n\n  /**\n   * Entity documentation.\n   */\n  std::string docs;\n\n  /**\n   * Entity title. This is used for the title of the page.\n   */\n  std::string title;\n\n  /**\n   * Alternative brief description.\n   */\n  std::string brief;\n\n  /**\n   * Group to which this belongs.\n   */\n  std::string ingroup;\n\n  /**\n   * Path of source file.\n   */\n  std::filesystem::path path;\n\n  /**\n   * Starting line in the source file.\n   */\n  uint32_t start_line;\n\n  /**\n   * Ending line in the source file.\n   */\n  uint32_t end_line;\n\n  /**\n   * For a file only, execution counts for lines. -1 for a line indicates that\n   * it is excluded.\n   */\n  std::vector&lt;int&gt; line_counts;\n\n  /**\n   * Number of lines included in coverage counts.\n   */\n  int lines_included;\n\n  /**\n   * Number of lines covered in coverage counts.\n   */\n  int lines_covered;\n\n  /**\n   * Entity type.\n   */\n  EntityType type;\n\n  /**\n   * Is this node visible? This is a computed quantity, that may be overridden\n   * explicitly with @p hide.\n   */\n  bool visible;\n\n  /**\n   * Hide this node?\n   */\n  bool hide;\n\nprivate:\n  /**\n   * Add child entity to a group.\n   * \n   * @param o Child entity with `ingroup` set.\n   * \n   * @return True if a group of the given name was found, in which case @p o\n   * will have been added to it, false otherwise.\n   */\n  bool addToGroup(Entity&amp;&amp; o);\n\n  /**\n   * Add child entity.\n   * \n   * @param o Child entity.\n   * \n   * If the child has `ingroup` set, it is ignored.\n   */\n  void addToThis(Entity&amp;&amp; o);\n};\n</code></pre>"},{"location":"demo/coverage/src/GcovCounter.cpp/","title":"GcovCounter.cpp","text":"<pre><code>#include \"GcovCounter.hpp\"\n#include \"YAMLParser.hpp\"\n\nvoid GcovCounter::count(const std::filesystem::path&amp; coverage, Entity&amp; root) {\n  /*\n  * A sketch of the format is:\n  * ```\n  *        -:    0:Source:/path/to/source/file.cpp\n  *        -:    1:#include &lt;iotream&gt;&gt;\n  *        -:    4:\n  *        -:    5:using namespace std;\n  *        -:    6:\n  *        1:    7:int main(int argc, char** argv) {\n  *        1:    8:  if (true) {\n  *        1:    9:    std::cout &lt;&lt; \"Hello, world!\" &lt;&lt; std::endl;\n  *        -:   10:  } else {\n  *    #####:   11:    std::cout &lt;&lt; \"Goodbye, world!\" &lt;&lt; std::endl;\n  *        -:   12:  }\n  *        1:   13:  return 0;\n  *        -:   14:}\n  * ```\n  * The first column gives counts, `#####` indicating zero count on an\n  * executable line. The second column gives line numbers, with the count\n  * starting from one. Counts followed by `*` indicate an aggregate count over\n  * function template instantiations; the function template instantiations\n  * then follow, separated by lines of dashes, with disaggregated counts.\n  * These disaggregated counts do not always seem complete, and so the\n  * aggregated counts are used instead---the disagregated counts are readily\n  * recognized and ignored due to the repetition of line numbers seen before.\n  */\n  static const std::regex regex_source(\"^\\\\s*-:\\\\s*0:Source:(.*)$\",\n      regex_flags);\n  static const std::regex regex_covered(\"^\\\\s*(\\\\d+)\\\\*?:\\\\s*(\\\\d+):.*$\",\n      regex_flags);\n\n  std::ifstream in(coverage);\n  if (!in.is_open()) {\n    throw std::runtime_error(\"could not read file \" + coverage.string());\n  }\n\n  std::filesystem::path path;\n  bool include = false;\n\n  std::list&lt;Entity*&gt; es;\n  Entity* file = nullptr;\n  size_t nlines = 0;  // number of lines in file\n  int max_line_number = 0;  // highest line number seen so far\n  std::string line;\n  std::smatch match;\n\n  while (std::getline(in, line)) {\n    if (std::regex_match(line, match, regex_source)) {\n      /* start of new file */\n      path = match[1].str();\n      if (path.is_absolute()) {\n        path = std::filesystem::relative(path);\n      }\n      include = root.exists(path);\n      if (include) {\n        es = root.get(path);\n        file = es.back();\n        nlines = file-&gt;line_counts.size();\n        max_line_number = 0;\n      }\n    } else if (include &amp;&amp; std::regex_match(line, match, regex_covered)) {\n      /* line data */\n      int line_number = std::stoi(match[2]) - 1;\n      int count = std::stoi(match[1]);\n      if (line_number &lt; 0 || size_t(line_number) &gt;= nlines) {\n        warn(\"in \" &lt;&lt; file &lt;&lt; \", \" &lt;&lt; path &lt;&lt; \":\" &lt;&lt; line_number &lt;&lt;\n            \" does not exist; ignoring, are source and coverage\" &lt;&lt;\n            \" files in sync?\");\n      } else if (count &gt; 0 &amp;&amp; line_number &gt; max_line_number) {\n        // ^ the check against max_line_number means skipping lines with\n        //   disaggregated counts that have already been accounted for in\n        //   aggregated counts\n        int&amp; line_count = file-&gt;line_counts[line_number];\n        if (line_count == 0) {\n          /* line is included in report and first time seeing it covered,\n           * update aggregate counts for whole path */\n          for (auto e : es) {\n            ++e-&gt;lines_covered;\n          }\n        }\n        if (line_count &gt;= 0) {\n          /* line is included in report, update count */\n          line_count += count;\n        }\n      }\n      max_line_number = std::max(max_line_number, line_number);\n    }\n  }\n}\n</code></pre>"},{"location":"demo/coverage/src/GcovCounter.hpp/","title":"GcovCounter.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n#include \"Entity.hpp\"\n\n/**\n * Gcov processor for coverage data.\n *\n * @ingroup developer\n */\nclass GcovCounter {\npublic:\n  /**\n   * Read in file and update coverage data.\n   * \n   * @param file Coverage file.\n   * @param root Root entity.\n   */\n  void count(const std::filesystem::path&amp; file, Entity&amp; root);\n};\n</code></pre>"},{"location":"demo/coverage/src/JSONCounter.cpp/","title":"JSONCounter.cpp","text":"<pre><code>#include \"JSONCounter.hpp\"\n#include \"YAMLParser.hpp\"\n\nvoid JSONCounter::count(const std::filesystem::path&amp; coverage, Entity&amp; root) {\n  YAMLParser parser;\n  YAMLNode node = parser.parse(coverage);\n  if (!node.isSequence(\"files\")) {\n    warn(\"missing 'files' key in \" &lt;&lt; coverage);\n  } else for (auto file : node.sequence(\"files\")) {\n    if (!file-&gt;isValue(\"file\")) {\n      warn(\"missing 'file' key in 'files' element in \" &lt;&lt; file);\n    } else if (!file-&gt;isSequence(\"lines\")) {\n      warn(\"missing 'lines' key in 'files' element in \" &lt;&lt; file);\n    } else {\n      auto lines = file-&gt;sequence(\"lines\");\n      std::filesystem::path path = file-&gt;value(\"file\");\n      if (path.is_absolute()) {\n        /* make the path relative to the current working directory */\n        path = std::filesystem::relative(path);\n      }\n      if (root.exists(path)) {  // otherwise not included\n        /* update line coverage for this file */\n        std::list&lt;Entity*&gt; es = root.get(path);\n        Entity* file = es.back();\n        size_t nlines = file-&gt;line_counts.size();\n        for (auto line : lines) {\n          if (!line-&gt;has(\"line_number\")) {\n            warn(\"missing 'line_number' key in 'lines' element in \" &lt;&lt; file);\n          } else if (!line-&gt;has(\"count\")) {\n            warn(\"missing 'count' key in 'lines' element in \" &lt;&lt; file);\n          } else {\n            int line_number = std::stoi(line-&gt;value(\"line_number\")) - 1;\n            int count = std::stoi(line-&gt;value(\"count\"));\n            if (line_number &lt; 0 || size_t(line_number) &gt;= nlines) {\n              warn(\"in \" &lt;&lt; file &lt;&lt; \", \" &lt;&lt; path &lt;&lt; \":\" &lt;&lt; line_number &lt;&lt;\n                  \" does not exist; ignoring, are source and coverage\" &lt;&lt;\n                  \" files in sync?\");\n            } else if (count &gt; 0) {\n              int&amp; line_count = file-&gt;line_counts[line_number];\n              if (line_count == 0) {\n                /* line is included in report and first time seeing it\n                 * covered, update aggregate counts for whole path */\n                for (auto e : es) {\n                  ++e-&gt;lines_covered;\n                }\n              }\n              if (line_count &gt;= 0) {\n                /* line is included in report, update count */\n                line_count += count;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"demo/coverage/src/JSONCounter.hpp/","title":"JSONCounter.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n#include \"Entity.hpp\"\n\n/**\n * JSON processor for coverage data following gcov/gcovr schema.\n * \n * @ingroup developer\n */\nclass JSONCounter {\npublic:\n  /**\n   * Read in file and update coverage data.\n   * \n   * @param file Coverage file.\n   * @param root Root entity.\n   */\n  void count(const std::filesystem::path&amp; file, Entity&amp; root);\n};\n</code></pre>"},{"location":"demo/coverage/src/JSONGenerator.cpp/","title":"JSONGenerator.cpp","text":"<pre><code>#include \"JSONGenerator.hpp\"\n\nvoid JSONGenerator::generate(const Entity&amp; root) {\n  /* JSON header */\n  std::cout &lt;&lt; \"{\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"  \\\"format_version:\\\": \\\"2\\\",\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"  \\\"gcovr/format_version\\\": \\\"0.6\\\",\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"  \\\"files\\\": [\" &lt;&lt; std::endl;\n\n  /* JSON body */\n  generate(root, 0);\n\n  /* JSON footer */\n  std::cout &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"  ]\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"}\" &lt;&lt; std::endl;\n}\n\nint JSONGenerator::generate(const Entity&amp; root, int nfiles) {\n  for (auto&amp; dir : root.dirs) {\n    nfiles = generate(dir, nfiles);\n  }\n  for (auto&amp; file : root.files) {\n    if (nfiles &gt; 0) {\n      std::cout &lt;&lt; \",\" &lt;&lt; std::endl;\n    }      \n    std::cout &lt;&lt; \"    {\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"      \\\"file\\\": \\\"\" &lt;&lt; file.name &lt;&lt; \"\\\",\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"      \\\"functions\\\": [],\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"      \\\"lines\\\": [\" &lt;&lt; std::endl;\n\n    /* line information; note lines are stored zero-based, but must be\n      * output 1-based */\n    uint32_t nlines = 0;\n    for (uint32_t line = 0; line &lt; file.line_counts.size(); ++line) {\n      if (file.line_counts[line] &gt;= 0) {\n        if (nlines &gt; 0) {\n          std::cout &lt;&lt; \",\" &lt;&lt; std::endl;\n        }\n        ++nlines;\n        std::cout &lt;&lt; \"        {\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"          \\\"line_number\\\": \" &lt;&lt; (line + 1) &lt;&lt; \",\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"          \\\"branches\\\": [],\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"          \\\"count\\\": \" &lt;&lt; file.line_counts[line] &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"        }\";\n      }\n    }\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"      ]\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"    }\";\n    ++nfiles;\n  }\n  return nfiles;\n}\n</code></pre>"},{"location":"demo/coverage/src/JSONGenerator.hpp/","title":"JSONGenerator.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n#include \"Entity.hpp\"\n\n/**\n * JSON generator for coverage data following gcov/gcovr schema.\n * \n * @ingroup developer\n */\nclass JSONGenerator {\npublic:\n  /**\n   * Generate coverage data.\n   * \n   * @param root Root entity.\n   */\n  void generate(const Entity&amp; root);\n\nprivate:\n  /**\n   * Generate documentation.\n   * \n   * @param root Root entity.\n   * @param nfiles Number of files output so far.\n   * \n   * @return Updated number of files output so far.\n   */\n  int generate(const Entity&amp; root, int nfiles);\n};\n</code></pre>"},{"location":"demo/coverage/src/MarkdownGenerator.cpp/","title":"MarkdownGenerator.cpp","text":"<pre><code>#include \"MarkdownGenerator.hpp\"\n#include \"YAMLParser.hpp\"\n\nMarkdownGenerator::MarkdownGenerator(const std::filesystem::path&amp; output) :\n    output(output) {\n  //\n}\n\nvoid MarkdownGenerator::generate(const Entity&amp; root, const bool cov) {\n  generate(output, root, cov);\n  if (cov) {\n    coverage(output, root);\n  }\n}\n\nvoid MarkdownGenerator::clean() {\n  if (std::filesystem::exists(output) &amp;&amp; std::filesystem::is_directory(output)) {\n    for (auto&amp; entry : std::filesystem::recursive_directory_iterator(output)) {\n      if (entry.is_regular_file() &amp;&amp; entry.path().extension() == \".md\" &amp;&amp;\n          !files.contains(entry)) {\n        try {\n          YAMLParser parser;\n          YAMLNode frontmatter = parser.parse(entry.path().string());\n          if (frontmatter.isValue(\"generator\") &amp;&amp;\n              frontmatter.value(\"generator\") == \"doxide\") {\n            std::filesystem::remove(entry.path());\n          }\n        } catch (const std::runtime_error&amp; e) {\n          warn(e.what());\n        }\n      }\n    }\n\n    /* traverse the output directory again, this time removing any empty\n     * directories; because removing a directory may make its parent directory\n     * empty, repeat until there are no further empty directories */\n    std::vector&lt;std::filesystem::path&gt; empty;\n    do {\n      empty.clear();\n      for (auto&amp; entry : std::filesystem::recursive_directory_iterator(output)) {\n        if (entry.is_directory() &amp;&amp; std::filesystem::is_empty(entry.path())) {\n          empty.push_back(entry.path());\n        }\n      }\n      for (auto&amp; dir : empty) {\n        std::filesystem::remove(dir);\n      }    \n    } while (empty.size());\n  }\n}\n\nvoid MarkdownGenerator::generate(const std::filesystem::path&amp; output,\n    const Entity&amp; entity, const bool cov) {\n  std::string name = sanitize(entity.name);  // entity name, empty for root\n  std::string dirname;   // directory name for this entity\n  std::string filename;  // file name for this entity\n  std::string childdir;  // directory name for children, relative to filename\n  if (entity.type == EntityType::ROOT) {\n    /* root node */\n    dirname = \"\";\n    filename = \"index\";\n    childdir = \"\";\n  } else if (entity.type == EntityType::TYPE) {\n    /* when building the navigation menu, mkdocs modifies directory names by\n     * replacing underscores and capitalizing words; this is problematic for\n     * type names; rather than generating the docs for a class at\n     * ClassName/index.md, they are generated at ClassName.md, but children\n     * still go in a ClassName/ subdirectory; final URLs are the same, but\n     * this unfortunately adds two links to the menu, one for the class,\n     * another with the same name that expands for the children, if they\n     * exist; this is not such a problem for classes, which don't often have\n     * children, so we prefer the option... */\n    dirname = \"\";\n    filename = name;\n    childdir = name + \"/\";\n  } else {\n    /* ...whereas namespaces and groups tend to have simpler names not\n     * affected by the mkdocs changes, while two links in the menu is a\n     * more unsightly, so don't change them */\n    dirname = name;\n    filename = \"index\";\n    childdir = \"\";\n  }\n\n  std::filesystem::create_directories(output / dirname);\n  std::filesystem::path file = output / dirname / (filename + \".md\");\n  if (can_write(file)) {\n    files.insert(file);\n    std::ofstream out(file);\n\n    /* frontmatter*/\n    out &lt;&lt; frontmatter(entity) &lt;&lt; std::endl;\n\n    /* header */\n    out &lt;&lt; \"# \" &lt;&lt; title(entity) &lt;&lt; std::endl;\n    out &lt;&lt; std::endl;\n    if (entity.type == EntityType::TYPE) {\n      out &lt;&lt; \"**\" &lt;&lt; htmlize(line(entity.decl)) &lt;&lt; \"**\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n    }\n    out &lt;&lt; entity.docs &lt;&lt; std::endl;\n    out &lt;&lt; std::endl;\n\n    /* groups */\n    for (auto&amp; child : view(entity.groups, false)) {\n      out &lt;&lt; \":material-format-section: [\" &lt;&lt; title(*child) &lt;&lt; ']';\n      out &lt;&lt; \"(\" &lt;&lt; childdir &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \"/index.md)\" &lt;&lt; std::endl;\n      out &lt;&lt; \":   \" &lt;&lt; line(brief(*child)) &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n    }\n\n    /* namespaces */\n    for (auto&amp; child : view(entity.namespaces, true)) {\n      out &lt;&lt; \":material-package: [\" &lt;&lt; child-&gt;name &lt;&lt; ']';\n      out &lt;&lt; \"(\" &lt;&lt; childdir &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \"/index.md)\" &lt;&lt; std::endl;\n      out &lt;&lt; \":   \" &lt;&lt; line(brief(*child)) &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n    }\n\n    /* code coverage */\n    if (entity.type == EntityType::ROOT &amp;&amp; cov) {\n      out &lt;&lt; \":material-chart-pie: [Code Coverage](coverage/index.md)\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n    }\n\n    /* brief descriptions */\n    auto types = view(entity.types,\n        entity.type == EntityType::NAMESPACE ||\n        entity.type == EntityType::GROUP);\n    if (types.size() &gt; 0) {\n      out &lt;&lt; \"## Types\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      out &lt;&lt; \"| Name | Description |\" &lt;&lt; std::endl;\n      out &lt;&lt; \"| ---- | ----------- |\" &lt;&lt; std::endl;\n      for (auto&amp; child : types) {\n        out &lt;&lt; \"| [\" &lt;&lt; child-&gt;name &lt;&lt; \"](\" &lt;&lt; childdir &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \".md) | \";\n        out &lt;&lt; line(brief(*child)) &lt;&lt; \" |\" &lt;&lt; std::endl;\n      }\n      out &lt;&lt; std::endl;\n    }\n\n    auto typedefs = view(entity.typedefs,\n        entity.type == EntityType::NAMESPACE ||\n        entity.type == EntityType::GROUP);\n    if (typedefs.size() &gt; 0) {\n      out &lt;&lt; \"## Type Aliases\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      out &lt;&lt; \"| Name | Description |\" &lt;&lt; std::endl;\n      out &lt;&lt; \"| ---- | ----------- |\" &lt;&lt; std::endl;\n      for (auto&amp; child : typedefs) {\n        out &lt;&lt; \"| [\" &lt;&lt; child-&gt;name &lt;&lt; \"](#\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \") | \";\n        out &lt;&lt; line(brief(*child)) &lt;&lt; \" |\" &lt;&lt; std::endl;\n      }\n      out &lt;&lt; std::endl;\n    }\n\n    auto concepts = view(entity.concepts,\n        entity.type == EntityType::NAMESPACE ||\n        entity.type == EntityType::GROUP);\n    if (concepts.size() &gt; 0) {\n      out &lt;&lt; \"## Concepts\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      out &lt;&lt; \"| Name | Description |\" &lt;&lt; std::endl;\n      out &lt;&lt; \"| ---- | ----------- |\" &lt;&lt; std::endl;\n      for (auto&amp; child : concepts) {\n        out &lt;&lt; \"| [\" &lt;&lt; child-&gt;name &lt;&lt; \"](#\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \") | \";\n        out &lt;&lt; line(brief(*child)) &lt;&lt; \" |\" &lt;&lt; std::endl;\n      }\n      out &lt;&lt; std::endl;\n    }\n\n    auto macros = view(entity.macros,\n        entity.type == EntityType::NAMESPACE ||\n        entity.type == EntityType::GROUP);\n    if (macros.size() &gt; 0) {\n      out &lt;&lt; \"## Macros\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      out &lt;&lt; \"| Name | Description |\" &lt;&lt; std::endl;\n      out &lt;&lt; \"| ---- | ----------- |\" &lt;&lt; std::endl;\n      for (auto&amp; child : macros) {\n        out &lt;&lt; \"| [\" &lt;&lt; child-&gt;name &lt;&lt; \"](#\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \") | \";\n        out &lt;&lt; line(brief(*child)) &lt;&lt; \" |\" &lt;&lt; std::endl;\n      }\n      out &lt;&lt; std::endl;\n    }\n\n    auto variables = view(entity.variables,\n        entity.type == EntityType::NAMESPACE ||\n        entity.type == EntityType::GROUP);\n    if (variables.size() &gt; 0) {\n      out &lt;&lt; \"## Variables\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      out &lt;&lt; \"| Name | Description |\" &lt;&lt; std::endl;\n      out &lt;&lt; \"| ---- | ----------- |\" &lt;&lt; std::endl;\n      for (auto&amp; child : variables) {\n        out &lt;&lt; \"| [\" &lt;&lt; child-&gt;name &lt;&lt; \"](#\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \") | \";\n        out &lt;&lt; line(brief(*child)) &lt;&lt; \" |\" &lt;&lt; std::endl;\n      }\n      out &lt;&lt; std::endl;\n    }\n\n    auto operators = view(entity.operators,\n          entity.type == EntityType::NAMESPACE ||\n          entity.type == EntityType::GROUP);\n    if (operators.size() &gt; 0) {\n      out &lt;&lt; \"## Operators\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      out &lt;&lt; \"| Name | Description |\" &lt;&lt; std::endl;\n      out &lt;&lt; \"| ---- | ----------- |\" &lt;&lt; std::endl;\n      for (auto&amp; child : operators) {\n        out &lt;&lt; \"| [\" &lt;&lt; child-&gt;name &lt;&lt; \"](#\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \") | \";\n        out &lt;&lt; line(brief(*child)) &lt;&lt; \" |\" &lt;&lt; std::endl;\n      }\n      out &lt;&lt; std::endl;\n    }\n\n    auto functions = view(entity.functions,\n          entity.type == EntityType::NAMESPACE ||\n          entity.type == EntityType::GROUP);\n    if (functions.size() &gt; 0) {\n      out &lt;&lt; \"## Functions\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      out &lt;&lt; \"| Name | Description |\" &lt;&lt; std::endl;\n      out &lt;&lt; \"| ---- | ----------- |\" &lt;&lt; std::endl;\n      for (auto&amp; child : functions) {\n        out &lt;&lt; \"| [\" &lt;&lt; child-&gt;name &lt;&lt; \"](#\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \") | \";\n        out &lt;&lt; line(brief(*child)) &lt;&lt; \" |\" &lt;&lt; std::endl;\n      }\n      out &lt;&lt; std::endl;\n    }\n\n    /* for an enumerator, output the possible values */\n    auto enums = view(entity.enums, false);\n    if (enums.size() &gt; 0) {\n      for (auto&amp; child : enums) {\n        out &lt;&lt; \"**\" &lt;&lt; child-&gt;decl &lt;&lt; \"**\" &lt;&lt; std::endl;\n        out &lt;&lt; \":   \" &lt;&lt; child-&gt;docs &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n      }\n      out &lt;&lt; std::endl;\n    }\n\n    /* detailed descriptions */\n    typedefs = view(entity.typedefs, true);\n    if (typedefs.size() &gt; 0) {\n      out &lt;&lt; \"## Type Alias Details\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      for (auto&amp; child : typedefs) {\n        out &lt;&lt; \"### \" &lt;&lt; child-&gt;name;\n        out &lt;&lt; \"&lt;a name=\\\"\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \"\\\"&gt;&lt;/a&gt;\" &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        out &lt;&lt; \"!!! typedef \\\"\" &lt;&lt; htmlize(line(child-&gt;decl)) &lt;&lt; '\"' &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        out &lt;&lt; indent(child-&gt;docs) &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n      }\n    }\n\n    concepts = view(entity.concepts, true);\n    if (concepts.size() &gt; 0) {\n      out &lt;&lt; \"## Concept Details\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      for (auto&amp; child : concepts) {\n        out &lt;&lt; \"### \" &lt;&lt; child-&gt;name;\n        out &lt;&lt; \"&lt;a name=\\\"\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \"\\\"&gt;&lt;/a&gt;\" &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        out &lt;&lt; \"!!! concept \\\"\" &lt;&lt; htmlize(line(child-&gt;decl)) &lt;&lt; '\"' &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        out &lt;&lt; indent(child-&gt;docs) &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n      }\n    }\n\n    macros = view(entity.macros, true);\n    if (macros.size() &gt; 0) {\n      out &lt;&lt; \"## Macro Details\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      for (auto&amp; child : macros) {\n        out &lt;&lt; \"### \" &lt;&lt; child-&gt;name;\n        out &lt;&lt; \"&lt;a name=\\\"\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \"\\\"&gt;&lt;/a&gt;\" &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        out &lt;&lt; \"!!! macro \\\"\" &lt;&lt; htmlize(line(child-&gt;decl)) &lt;&lt; '\"' &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        out &lt;&lt; indent(child-&gt;docs) &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n      }\n    }\n\n    variables = view(entity.variables, true);\n    if (variables.size() &gt; 0) {\n      out &lt;&lt; \"## Variable Details\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      for (auto&amp; child : variables) {\n        out &lt;&lt; \"### \" &lt;&lt; child-&gt;name;\n        out &lt;&lt; \"&lt;a name=\\\"\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \"\\\"&gt;&lt;/a&gt;\" &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        out &lt;&lt; \"!!! variable \\\"\" &lt;&lt; htmlize(line(child-&gt;decl)) &lt;&lt; '\"' &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        out &lt;&lt; indent(child-&gt;docs) &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n      }\n    }\n\n    operators = view(entity.operators, true);\n    if (operators.size() &gt; 0) {\n      out &lt;&lt; \"## Operator Details\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      std::string prev;\n      for (auto&amp; child : operators) {\n        if (child-&gt;name != prev) {\n          /* heading only for the first overload of this name */\n          out &lt;&lt; \"### \" &lt;&lt; child-&gt;name;\n          out &lt;&lt; \"&lt;a name=\\\"\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \"\\\"&gt;&lt;/a&gt;\" &lt;&lt; std::endl;\n          out &lt;&lt; std::endl;\n        }\n        out &lt;&lt; \"!!! function \\\"\" &lt;&lt; htmlize(line(child-&gt;decl)) &lt;&lt; '\"' &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        out &lt;&lt; indent(child-&gt;docs) &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        prev = child-&gt;name;\n      }\n    }\n\n    functions = view(entity.functions, true);\n    if (functions.size() &gt; 0) {\n      out &lt;&lt; \"## Function Details\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      std::string prev;\n      for (auto&amp; child : functions) {\n        if (child-&gt;name != prev) {\n          /* heading only for the first overload of this name */\n          out &lt;&lt; \"### \" &lt;&lt; child-&gt;name;\n          out &lt;&lt; \"&lt;a name=\\\"\" &lt;&lt; sanitize(child-&gt;name) &lt;&lt; \"\\\"&gt;&lt;/a&gt;\" &lt;&lt; std::endl;\n        }\n        out &lt;&lt; \"!!! function \\\"\" &lt;&lt; htmlize(line(child-&gt;decl)) &lt;&lt; '\"' &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        out &lt;&lt; indent(child-&gt;docs) &lt;&lt; std::endl;\n        out &lt;&lt; std::endl;\n        prev = child-&gt;name;\n      }\n    }\n  }\n\n  /* child pages */\n  std::filesystem::create_directories(output / name);\n  for (auto&amp; child : view(entity.groups, false)) {\n    generate(output / name, *child, cov);\n  }\n  for (auto&amp; child : view(entity.namespaces, false)) {\n    generate(output / name, *child, cov);\n  }\n  for (auto&amp; child : view(entity.types, false)) {\n    generate(output / name, *child, cov);\n  }\n}\n\nvoid MarkdownGenerator::coverage(const std::filesystem::path&amp; output,\n    const Entity&amp; entity) {\n  std::string name = sanitize(entity.type == EntityType::ROOT ?\n      \"coverage\" : entity.name);  // entity name, \"coverage\"\" for root\n  std::string dirname;  // directory name for this entity\n  std::string filename;  // file name for this entity\n  std::string childdir;  // directory name for children, relative to filename\n  if (entity.type == EntityType::FILE) {\n    /* as for types in generate(), working around some mkdocs behavior */\n    dirname = \"\";\n    filename = name;\n    childdir = name + \"/\";\n  } else {\n    dirname = name;\n    filename = \"index\";\n    childdir = \"\";\n  }\n\n  std::filesystem::create_directories(output / dirname);\n  std::filesystem::path file = output / dirname / (filename + \".md\");\n  if (can_write(file)) {\n    files.insert(file);\n    std::ofstream out(file);\n\n    /* frontmatter*/\n    out &lt;&lt; frontmatter(entity) &lt;&lt; std::endl;\n\n    /* header */\n    if (entity.type == EntityType::ROOT) {\n      out &lt;&lt; \"# Code Coverage\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n    } else {\n      out &lt;&lt; \"# \" &lt;&lt; title(entity) &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n      out &lt;&lt; entity.docs &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n    }\n\n    if (entity.type == EntityType::ROOT || entity.type == EntityType::DIR) {\n      /* code coverage chart */\n      sunburst(entity, entity, out);\n      out &lt;&lt; std::endl;\n\n      /* code coverage table */\n      out &lt;&lt; \"&lt;table&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;thead&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;tr&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;th style=\\\"text-align:left;\\\" data-sort-method=\\\"dotsep\\\"&gt;Name&lt;/th&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;th style=\\\"text-align:right;\\\" data-sort-method=\\\"number\\\"&gt;Lines&lt;/th&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;th style=\\\"text-align:right;\\\" data-sort-method=\\\"number\\\"&gt;Covered&lt;/th&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;th style=\\\"text-align:right;\\\" data-sort-method=\\\"number\\\"&gt;Uncovered&lt;/th&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;th style=\\\"text-align:right;\\\" data-sort-method=\\\"number\\\"&gt;Coverage&lt;/th&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;/tr&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;/thead&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;tbody&gt;\" &lt;&lt; std::endl;\n      coverage_data(entity, entity, out);\n      out &lt;&lt; \"&lt;/tbody&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;tfoot&gt;\" &lt;&lt; std::endl;\n      coverage_foot(entity, entity, out);\n      out &lt;&lt; \"&lt;/tfoot&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \"&lt;/table&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n    } else if (entity.type == EntityType::FILE) {\n      /* for a file, output the whole contents; line numbers are added with\n       * the Markdown notation `linenums=\"1\"`, which ultimately creates a HTML\n       * &lt;table&gt; of one row &lt;tr&gt;, with two cells &lt;td&gt;, the first holding the\n       * line numbers and the second the code; the line number cell contains\n       * a further &lt;pre&gt; with one empty &lt;span&gt;&lt;/span&gt;, then each line number\n       * in a separate &lt;span&gt; within it; to indicate code coverage we apply\n       * styles to those &lt;span&gt;, which are readily selected by number using\n       * the CSS nth-child() pseudo-class */\n      const std::string&amp; covered_color = color(100.0);\n      const std::string&amp; uncovered_color = color(0.0);\n\n      /* style sheet to highlight lines according to code coverage */\n      out &lt;&lt; \"&lt;style&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; \".linenodiv pre span {\";\n      out &lt;&lt; \"padding-left:4px;padding-right:4px\";\n      out &lt;&lt; \"}\" &lt;&lt; std::endl;\n      for (uint32_t line = 0; line &lt; entity.line_counts.size(); ++line) {\n        if (entity.line_counts[line] &gt; 0) {\n          /* line is covered; line + 2 here to account for 0-base to 1-base\n          * conversion plus the extra empty &lt;span&gt;&lt;/span&gt; mentioned above */\n          out &lt;&lt; \".linenodiv pre span:nth-child(\" &lt;&lt; (line + 2) &lt;&lt; \") {\";\n          out &lt;&lt; \"background-color: #\" &lt;&lt; covered_color &lt;&lt; \"dd;\";\n          out &lt;&lt; \"color: white;\";\n          out &lt;&lt; \"}\" &lt;&lt; std::endl;\n          out &lt;&lt; \".linenodiv pre span:nth-child(\" &lt;&lt; (line + 2) &lt;&lt; \")::before {\";\n          out &lt;&lt; \"content: \\\"\u25cf \\\";\";\n          out &lt;&lt; \"}\" &lt;&lt; std::endl;\n        } else if (entity.line_counts[line] == 0) {\n          /* line is uncovered; line + 2 here to account for 0-base to 1-base\n          * conversion plus the extra empty &lt;span&gt;&lt;/span&gt; mentioned above */\n          out &lt;&lt; \".linenodiv pre span:nth-child(\" &lt;&lt; (line + 2) &lt;&lt; \") {\";\n          out &lt;&lt; \"background-color: #\" &lt;&lt; uncovered_color &lt;&lt; \"dd;\";\n          out &lt;&lt; \"color: white;\";\n          out &lt;&lt; \"}\" &lt;&lt; std::endl;\n          out &lt;&lt; \".linenodiv pre span:nth-child(\" &lt;&lt; (line + 2) &lt;&lt; \")::before {\";\n          out &lt;&lt; \"content: \\\"\u25cb \\\";\";\n          out &lt;&lt; \"}\" &lt;&lt; std::endl;\n        }\n      }\n      out &lt;&lt; \"&lt;/style&gt;\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n\n      /* lines numbers and source code */\n      out &lt;&lt; \"```cpp linenums=\\\"1\\\"\" &lt;&lt; std::endl;\n      out &lt;&lt; entity.decl &lt;&lt; std::endl;\n      out &lt;&lt; \"```\" &lt;&lt; std::endl;\n      out &lt;&lt; std::endl;\n    }\n  }\n\n  /* child pages */\n  std::filesystem::create_directories(output / name);\n  for (auto&amp; child : view(entity.dirs, false)) {\n    coverage(output / name, *child);\n  }\n  for (auto&amp; child : view(entity.files, false)) {\n    coverage(output / name, *child);\n  }\n}\n\nvoid MarkdownGenerator::coverage_data(const Entity&amp; entity,\n    const Entity&amp; root, std::ofstream&amp; out) {\n  /* icons */\n  static std::string material_file_outline(\"&lt;span class=\\\"twemoji\\\"&gt;&lt;svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 24 24\\\"&gt;&lt;path d=\\\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8zm4 18H6V4h7v5h5z\\\"/&gt;&lt;/svg&gt;&lt;/span&gt;\");\n  static std::string material_folder(\"&lt;span class=\\\"twemoji\\\"&gt;&lt;svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 24 24\\\"&gt;&lt;path d=\\\"M10 4H4c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-8z\\\"/&gt;&lt;/svg&gt;&lt;/span&gt;\");\n\n  /* &lt;tr&gt; includes a data-parent attribute to facilitate filtering the table\n   * dynamically based on the currently-selected directory */\n\n  /* &lt;td&gt; includes data-sort (used by tablesort) for the names column to\n   * prefix directory names with \"a.\" and file names with \"b.\" for the\n   * purposes of sorting using the 'dotsep' sort order */\n\n  auto dirs = view(entity.dirs, true);\n  for (auto&amp; child : dirs) {\n    std::string parent = sanitize(relative(child-&gt;path.parent_path(), root.path));\n    std::string name = sanitize(child-&gt;name);\n    uint32_t lines_included = child-&gt;lines_included;\n    uint32_t lines_covered = child-&gt;lines_covered;\n    uint32_t lines_uncovered = lines_included - lines_covered;\n    double lines_percent = (lines_included &gt; 0) ?\n        100.0*lines_covered/lines_included : 100.0;\n    const std::string&amp; lines_color = color(lines_percent);\n    std::string path = parent.empty() ? name : parent + '/' + name;\n    std::string style = parent.empty() ? \"\" : \" style=\\\"display:none;\\\"\";\n\n    out &lt;&lt; \"&lt;tr id=\\\"\" &lt;&lt; path &lt;&lt; \"\\\" data-parent=\\\"\" &lt;&lt; parent &lt;&lt; \"\\\"\" &lt;&lt; style &lt;&lt; \"&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;td style=\\\"text-align:left;\\\" data-sort=\\\"a.\" &lt;&lt; name &lt;&lt; \"\\\"&gt;\" &lt;&lt; material_folder &lt;&lt; \" &lt;a href=\\\"\" &lt;&lt; path &lt;&lt; \"/\\\"&gt;\" &lt;&lt; htmlize(child-&gt;name) &lt;&lt; \"&lt;/a&gt;&lt;/td&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;td style=\\\"text-align:right;\\\"&gt;\" &lt;&lt; lines_included &lt;&lt; \"&lt;/td&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;td style=\\\"text-align:right;\\\"&gt;\" &lt;&lt; lines_covered &lt;&lt; \"&lt;/td&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;td style=\\\"text-align:right;\\\"&gt;\" &lt;&lt; lines_uncovered &lt;&lt; \"&lt;/td&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;td style=\\\"text-align:right;box-shadow: -8px 0 0 0 #\" &lt;&lt; lines_color &lt;&lt; \"dd inset;\\\"&gt;\" &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; lines_percent &lt;&lt; \"%&lt;/td&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;/tr&gt;\" &lt;&lt; std::endl;\n\n    coverage_data(*child, root, out);\n  }\n\n  auto files = view(entity.files, true);\n  for (auto&amp; child : files) {\n    std::string parent = sanitize(relative(child-&gt;path.parent_path(), root.path));\n    std::string name = sanitize(child-&gt;name);\n    uint32_t lines_included = child-&gt;lines_included;\n    uint32_t lines_covered = child-&gt;lines_covered;\n    uint32_t lines_uncovered = lines_included - lines_covered;\n    double lines_percent = (lines_included &gt; 0) ?\n        100.0*lines_covered/lines_included : 100.0;\n    const std::string&amp; lines_color = color(lines_percent);\n    std::string path = parent.empty() ? name : parent + '/' + name;\n    std::string style = parent.empty() ? \"\" : \" style=\\\"display:none;\\\"\";\n\n    out &lt;&lt; \"&lt;tr id=\\\"\" &lt;&lt; path &lt;&lt; \"\\\" data-parent=\\\"\" &lt;&lt; parent &lt;&lt; \"\\\"\" &lt;&lt; style &lt;&lt; \"&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;td style=\\\"text-align:left;\\\" data-sort=\\\"b.\" &lt;&lt; name &lt;&lt; \"\\\"&gt;\" &lt;&lt; material_file_outline &lt;&lt; \" &lt;a href=\\\"\" &lt;&lt; path &lt;&lt; \"/\\\"&gt;\" &lt;&lt; htmlize(child-&gt;name) &lt;&lt; \"&lt;/a&gt;&lt;/td&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;td style=\\\"text-align:right;\\\"&gt;\" &lt;&lt; lines_included &lt;&lt; \"&lt;/td&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;td style=\\\"text-align:right;\\\"&gt;\" &lt;&lt; lines_covered &lt;&lt; \"&lt;/td&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;td style=\\\"text-align:right;\\\"&gt;\" &lt;&lt; lines_uncovered &lt;&lt; \"&lt;/td&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;td style=\\\"text-align:right;box-shadow: -8px 0 0 0 #\" &lt;&lt; lines_color &lt;&lt; \"dd inset;\\\"&gt;\" &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; lines_percent &lt;&lt; \"%&lt;/td&gt;\" &lt;&lt; std::endl;\n    out &lt;&lt; \"&lt;/tr&gt;\" &lt;&lt; std::endl;\n  }\n}\n\nvoid MarkdownGenerator::coverage_foot(const Entity&amp; entity,\n    const Entity&amp; root, std::ofstream&amp; out) {\n  auto dirs = view(entity.dirs, true);\n  for (auto&amp; child : dirs) {\n    coverage_foot(*child, root, out);\n  }\n\n  /* here data-parent is set to the name of the entity itself, not its parent,\n   * as the summary row in the footer should be shown when the entity is\n   * selected as the root */\n  std::string name = sanitize(entity.path.string());\n  uint32_t lines_included = entity.lines_included;\n  uint32_t lines_covered = entity.lines_covered;\n  uint32_t lines_uncovered = lines_included - lines_covered;\n  double lines_percent = (lines_included &gt; 0) ?\n      100.0*lines_covered/lines_included : 100.0;\n  const std::string&amp; lines_color = color(lines_percent);\n  std::string style = (name == root.path.string()) ? \"\" : \", style=\\\"display:none;\\\"\";\n\n  out &lt;&lt; \"&lt;tr id=\\\"summary.\" &lt;&lt; name &lt;&lt; \"\\\" data-parent=\\\"\" &lt;&lt; name &lt;&lt; \"\\\"\" &lt;&lt; style &lt;&lt; \"&gt;\" &lt;&lt; std::endl;\n  out &lt;&lt; \"&lt;td style=\\\"text-align:left;font-weight:bold;\\\"&gt;Summary&lt;/td&gt;\" &lt;&lt; std::endl;\n  out &lt;&lt; \"&lt;td style=\\\"text-align:right;font-weight:bold;\\\"&gt;\" &lt;&lt; lines_included &lt;&lt; \"&lt;/td&gt;\" &lt;&lt; std::endl;\n  out &lt;&lt; \"&lt;td style=\\\"text-align:right;font-weight:bold;\\\"&gt;\" &lt;&lt; lines_covered &lt;&lt; \"&lt;/td&gt;\" &lt;&lt; std::endl;\n  out &lt;&lt; \"&lt;td style=\\\"text-align:right;font-weight:bold;\\\"&gt;\" &lt;&lt; lines_uncovered &lt;&lt; \"&lt;/td&gt;\" &lt;&lt; std::endl;\n  out &lt;&lt; \"&lt;td style=\\\"text-align:right;font-weight:bold;box-shadow: -8px 0 0 0 #\" &lt;&lt; lines_color &lt;&lt; \"dd inset;\\\"&gt;\" &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; lines_percent &lt;&lt; \"%&lt;/td&gt;\" &lt;&lt; std::endl;\n  out &lt;&lt; \"&lt;/tr&gt;\" &lt;&lt; std::endl;\n}\n\nvoid MarkdownGenerator::sunburst(const Entity&amp; entity, const Entity&amp; root,\n    std::ofstream&amp; out) {\n  out &lt;&lt;\n  R\"\"\"\"(\n  &lt;div style=\"position:relative;width:100%;padding-top:100%;\"&gt;\n    &lt;div id=\"coverage-sunburst\" style=\"position:absolute;top:0;left:0;width:100%;height:100%;\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script src=\"https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js\"&gt;&lt;/script&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  )\"\"\"\";\n  out &lt;&lt; \"var data = [\";\n  sunburst_data(entity, root, out);\n  out &lt;&lt; ']' &lt;&lt; std::endl;\n  out &lt;&lt;\n  R\"\"\"\"(\n  var coverage_root = \"\";  // current root of coverage report\n  function update_coverage_table(params) {\n    if (typeof params.data.name === 'undefined') {\n      // occurs when the central circle is selected to go up one level\n      var path = coverage_root.substring(0, coverage_root.lastIndexOf('/'));\n      var is_dir = true;\n    } else {\n      var path = params.data.path;\n      var is_dir = params.data.type === 'dir';\n    }\n    let rows = document.querySelectorAll('[data-parent]');\n    if (is_dir) {\n      for (let row of rows) {\n        if (row.dataset.parent === path) {\n          row.style.display = '';\n        } else {\n          row.style.display = 'none';\n        }\n      }\n    } else {\n      for (let row of rows) {\n        if (row.id === path) {\n          row.style.display = '';\n        } else {\n          row.style.display = 'none';\n        }\n      }\n    }\n    coverage_root = path;\n  }\n\n  var coverage_sunburst = echarts.init(document.getElementById('coverage-sunburst'));\n  var option = {\n    series: {\n      type: 'sunburst',\n      data: data,\n      sort: null,\n      radius: ['5%', '95%'],\n      startAngle: 0,\n      clockwise: false,\n      itemStyle: {\n        borderWidth: 1\n      },\n      label: {\n        color: 'white',\n        fontSize: 10,\n        textBorderWidth: 1,\n        align: 'center',\n        rotate: 'radial',\n        width: 80,\n        minAngle: 4,\n        overflow: 'truncate',\n        formatter: function (params) {\n          if (params.data.icon) {\n            return params.name + '\\n' + params.data.icon;\n          } else {\n            return params.name;\n          }\n        }\n      },\n      labelLayout: {\n        hideOverlap: true\n      },\n      levels: [\n        {\n          itemStyle: {\n            opacity: 0.2\n          }\n        }\n      ]\n    }\n  };\n  coverage_sunburst.setOption(option);\n  coverage_sunburst.on('click', update_coverage_table);\n  window.addEventListener(\"resize\", () =&gt; {\n    coverage_sunburst.resize();\n  });\n  &lt;/script&gt;\n  )\"\"\"\";\n}\n\nvoid MarkdownGenerator::sunburst_data(const Entity&amp; entity,\n    const Entity&amp; root, std::ofstream&amp; out) {\n  bool first = true;\n  for (auto&amp; dir: view(entity.dirs, true)) {\n    double percent = (dir-&gt;lines_included &gt; 0) ?\n        100.0*dir-&gt;lines_covered/dir-&gt;lines_included : 100.0;\n    const std::string&amp; c = color(percent);\n    const std::string&amp; ico = icon(percent);\n    std::filesystem::path path = relative(dir-&gt;path, root.path);\n\n    if (!first) {\n      out &lt;&lt; \", \";\n    }\n    first = false;\n\n    out &lt;&lt; '{';\n    out &lt;&lt; \"name: \\\"\" &lt;&lt; dir-&gt;name &lt;&lt; \"\\\", \";\n    out &lt;&lt; \"path: \\\"\" &lt;&lt; path.string() &lt;&lt; \"\\\", \";\n    out &lt;&lt; \"value: \" &lt;&lt; dir-&gt;lines_included &lt;&lt; \", \";\n    out &lt;&lt; \"type: \\\"dir\\\", \";\n    out &lt;&lt; \"icon: \\\"\" &lt;&lt; ico &lt;&lt; \"\\\", \";\n    out &lt;&lt; \"children: [\";\n    sunburst_data(*dir, root, out);\n    out &lt;&lt; \"], \";\n    out &lt;&lt; \"itemStyle: { color: \\\"#\" &lt;&lt; c &lt;&lt; \"dd\\\", borderColor: \\\"#\" &lt;&lt; c &lt;&lt; \"\\\"}, \";\n    out &lt;&lt; \"label: { textBorderColor: \\\"#\" &lt;&lt; c &lt;&lt; \"\\\"}\";\n    out &lt;&lt; '}';\n  }\n  for (auto&amp; file: view(entity.files, true)) {\n    double percent = (file-&gt;lines_included &gt; 0) ?\n        100.0*file-&gt;lines_covered/file-&gt;lines_included : 100.0;\n    const std::string&amp; c = color(percent);\n    const std::string&amp; ico = icon(percent);\n    std::filesystem::path path = relative(file-&gt;path, root.path);\n\n    if (!first) {\n      out &lt;&lt; \", \";\n    }\n    first = false;\n\n    out &lt;&lt; '{';\n    out &lt;&lt; \"name: \\\"\" &lt;&lt; file-&gt;name &lt;&lt; \"\\\", \";\n    out &lt;&lt; \"path: \\\"\" &lt;&lt; path.string() &lt;&lt; \"\\\", \";\n    out &lt;&lt; \"value: \" &lt;&lt; file-&gt;lines_included &lt;&lt; \", \";\n    out &lt;&lt; \"type: \\\"file\\\", \";\n    out &lt;&lt; \"icon: \\\"\" &lt;&lt; ico &lt;&lt; \"\\\", \";\n    out &lt;&lt; \"itemStyle: { color: \\\"#\" &lt;&lt; c &lt;&lt; \"dd\\\", borderColor: \\\"#\" &lt;&lt; c &lt;&lt; \"\\\"}, \";\n    out &lt;&lt; \"label: { textBorderColor: \\\"#\" &lt;&lt; c &lt;&lt; \"\\\"}\";\n    out &lt;&lt; '}';\n  }\n}\n\nbool MarkdownGenerator::can_write(const std::filesystem::path&amp; path) {\n  bool canWrite = true;\n  if (std::filesystem::exists(path)) {\n    try {\n      YAMLParser parser;\n      YAMLNode node = parser.parse(path.string());\n      canWrite = node.isValue(\"generator\") &amp;&amp; node.value(\"generator\") == \"doxide\";\n    } catch (const std::runtime_error&amp; e) {\n      warn(e.what());\n      canWrite = false;\n    }\n  }\n  if (!canWrite) {\n    warn(path.string() &lt;&lt; \" already exists and was not generated by doxide, will not overwrite\");\n  }\n  return canWrite;\n}\n\nstd::string MarkdownGenerator::relative(const std::filesystem::path&amp; path,\n    const std::filesystem::path&amp; base) {\n  if (base.empty()) {\n    return path.string();\n  } else {\n    std::filesystem::path result = std::filesystem::relative(path, base);\n    if (result == \".\") {\n      return \"\";\n    } else {\n      return result.string();\n    }\n  }\n}\n\nstd::string MarkdownGenerator::frontmatter(const Entity&amp; entity) {\n  /* use YAML frontmatter to ensure correct capitalization of title, and to\n   * mark as managed by Doxide */\n  std::stringstream buf;\n  buf &lt;&lt; \"---\" &lt;&lt; std::endl;\n  buf &lt;&lt; \"generator: doxide\" &lt;&lt; std::endl;\n  buf &lt;&lt; \"---\" &lt;&lt; std::endl;\n  buf &lt;&lt; std::endl;\n  return buf.str();\n}\n\nstd::string MarkdownGenerator::title(const Entity&amp; entity) {\n  if (!entity.title.empty()) {\n    return entity.title;\n  } else {\n    return entity.name;\n  }\n}\n\nstd::string MarkdownGenerator::brief(const Entity&amp; entity) {\n  if (!entity.brief.empty()) {\n    return entity.brief;\n  } else {\n    static const std::regex reg(\"^(`.*?`|\\\\[.*?\\\\]\\\\(.*?\\\\)|[^;:.?!])*[\\\\.\\\\?\\\\!](?=\\\\s|$)\",\n        regex_flags);\n    std::string l = line(entity.docs);\n    std::smatch match;\n    if (std::regex_search(l, match, reg)) {\n      return match.str();\n    } else {\n      return l;\n    }\n  }\n}\n\nstd::string MarkdownGenerator::line(const std::string&amp; str) {\n  static const std::regex newline(\"\\\\s*\\\\n\\\\s*\", regex_flags);\n  return std::regex_replace(str, newline, \" \");\n}\n\nstd::string MarkdownGenerator::indent(const std::string&amp; str) {\n  static const std::regex start(\"\\\\n\", regex_flags);\n  return \"    \" + std::regex_replace(str, start, \"\\n    \");\n}\n\nstd::string MarkdownGenerator::stringify(const std::string&amp; str) {\n  static const std::regex quote(\"(\\\"|\\\\\\\\)\", regex_flags);\n  std::string r;\n  r.append(\"\\\"\");\n  r.append(std::regex_replace(str, quote, \"\\\\$1\"));\n  r.append(\"\\\"\");\n  return r;\n}\n\nstd::string MarkdownGenerator::htmlize(const std::string&amp; str) {\n  /* basic replacements */\n  static const std::regex amp(\"&amp;\", regex_flags);\n  static const std::regex lt(\"&lt;\", regex_flags);\n  static const std::regex gt(\"&gt;\", regex_flags);\n  static const std::regex quot(\"\\\"\", regex_flags);\n  static const std::regex apos(\"'\", regex_flags);\n  static const std::regex ptr(\"\\\\*\", regex_flags);\n\n  /* the sequence operator[](...) looks like a link in Markdown */\n  static const std::regex operator_brackets(\"operator\\\\[\\\\]\", regex_flags);\n\n  std::string r = str;\n  r = std::regex_replace(r, amp, \"&amp;amp;\");  // must go first or new &amp; replaced\n  r = std::regex_replace(r, lt, \"&amp;lt;\");\n  r = std::regex_replace(r, gt, \"&amp;gt;\");\n  r = std::regex_replace(r, quot, \"&amp;quot;\");\n  r = std::regex_replace(r, apos, \"&amp;apos;\");\n  r = std::regex_replace(r, ptr, \"&amp;#42;\");\n  r = std::regex_replace(r, operator_brackets, \"operator&amp;#91;&amp;#93;\");\n  return r;\n}\n\nstd::string MarkdownGenerator::sanitize(const std::string&amp; str) {\n  static const std::regex word(\"\\\\w|[./\\\\\\\\]\", regex_flags);\n  static const std::regex space(\"\\\\s\", regex_flags);\n\n  std::stringstream buf;\n  for (auto iter = str.begin(); iter != str.end(); ++iter) {\n    if (std::regex_match(iter, iter + 1, word)) {\n      buf &lt;&lt; *iter;\n    } else if (std::regex_match(iter, iter + 1, space)) {\n      // skip whitespace\n    } else {\n      /* encode non-word and non-space characters */\n      buf &lt;&lt; \"_u\" &lt;&lt; std::setfill('0') &lt;&lt; std::setw(4) &lt;&lt; std::hex &lt;&lt; int(*iter);\n    }\n  }\n\n  /* on Linux and Mac, the maximum file name length is 255 bytes, plus leave\n   * room for a four-character file extension (e.g. .html); on Windows it is\n   * 260 bytes, so use the minimum */\n  return buf.str().substr(0, 255 - 5);\n}\n\nconst std::string&amp; MarkdownGenerator::color(const double percent) {\n  assert(0.0 &lt;= percent &amp;&amp; percent &lt;= 100.0);\n\n  static const std::string red = \"ef5552\";\n  static const std::string orange = \"f78b2b\";\n  static const std::string amber = \"ffc105\";\n  static const std::string olive = \"a5b72a\";\n  static const std::string green = \"4cae4f\";\n\n  if (percent &lt; 60.0) {\n    return red;\n  } else if (percent &lt; 70.0) {\n    return orange;\n  } else if (percent &lt; 80.0) {\n    return amber;\n  } else if (percent &lt; 90.0) {\n    return olive;\n  } else {\n    return green;\n  }\n}\n\nconst std::string&amp; MarkdownGenerator::icon(const double percent) {\n  assert(0.0 &lt;= percent &amp;&amp; percent &lt;= 100.0);\n\n  static const std::string icon0 = \"\u25cb\u25cb\u25cb\u25cb\";\n  static const std::string icon1 = \"\u25cf\u25cb\u25cb\u25cb\";\n  static const std::string icon2 = \"\u25cf\u25cf\u25cb\u25cb\";\n  static const std::string icon3 = \"\u25cf\u25cf\u25cf\u25cb\";\n  static const std::string icon4 = \"\u25cf\u25cf\u25cf\u25cf\";\n\n  if (percent &lt; 60.0) {\n    return icon0;\n  } else if (percent &lt; 70.0) {\n    return icon1;\n  } else if (percent &lt; 80.0) {\n    return icon2;\n  } else if (percent &lt; 90.0) {\n    return icon3;\n  } else {\n    return icon4;\n  }\n}\n\nstd::list&lt;const Entity*&gt; MarkdownGenerator::view(\n    const std::list&lt;Entity&gt;&amp; entities, const bool sort) {\n  auto pointer = [](const Entity&amp; e) {\n    return &amp;e;\n  };\n  auto hide = [](const Entity* e) {\n    return !e-&gt;visible || e-&gt;hide;\n  };\n  auto compare = [](const Entity* a, const Entity* b) {\n    return a-&gt;name &lt; b-&gt;name;\n  };\n\n  std::list&lt;const Entity*&gt; ptrs;\n  auto end = std::back_inserter(ptrs);\n  std::transform(entities.begin(), entities.end(), end, pointer);\n  ptrs.erase(std::remove_if(ptrs.begin(), ptrs.end(), hide), ptrs.end());\n  if (sort) {\n    ptrs.sort(compare);\n  }\n  return ptrs;\n}\n</code></pre>"},{"location":"demo/coverage/src/MarkdownGenerator.hpp/","title":"MarkdownGenerator.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n#include \"Entity.hpp\"\n\n/**\n * Markdown generator.\n * \n * @ingroup developer\n */\nclass MarkdownGenerator {\npublic:\n  /**\n   * Constructor.\n   * \n   * @param output Output directory.\n   */\n  MarkdownGenerator(const std::filesystem::path&amp; output);\n\n  /**\n   * Generate documentation.\n   * \n   * @param root Root entity.\n   * @param cov Include code coverage report?\n   */\n  void generate(const Entity&amp; root, const bool cov);\n\n  /**\n   * Clean up after generation, removing files from old runs. Traverses the\n   * output directory, removing any Markdown files with 'generator: doxide' in\n   * their YAML frontmatter that were not generated by previous calls of\n   * `generate()`.\n   */\n  void clean();\n\nprivate:\n  /**\n   * Recursively generate documentation.\n   * \n   * @param output Output directory.\n   * @param entity Entity for which to generate documentation.\n   * @param cov Include code coverage report?\n   */\n  void generate(const std::filesystem::path&amp; output, const Entity&amp; entity,\n      const bool cov);\n\n  /**\n   * Recursively generate coverage.\n   * \n   * @param output Output directory.\n   * @param entity Entity for which to generate coverage.\n   */\n  void coverage(const std::filesystem::path&amp; output, const Entity&amp; entity);\n\n  /**\n   * Recursively generate coverage table data.\n   * \n   * @param entity Entity for which to generate coverage.\n   * @param root Root entity for the current page. This is used to determine\n   * which are rows should be visible initially.\n   * @param out Output stream.\n   */\n  static void coverage_data(const Entity&amp; entity, const Entity&amp; root,\n      std::ofstream&amp; out);\n\n  /**\n   * Recursively generate coverage table footer.\n   * \n   * @param entity Entity for which to generate coverage.\n   * @param root Root entity for the current page. This is used to determine\n   * which are rows should be visible initially.\n   * @param out Output stream.\n   */\n  static void coverage_foot(const Entity&amp; entity, const Entity&amp; root,\n      std::ofstream&amp; out);\n\n  /**\n   * Produce sunburst chart of code coverage for entity.\n   * \n   * @param entity Entity for which to generate sunburst.\n   * @param root Root entity for the current page. This is used to determine\n   * paths relative to the root.\n   * @param out Output stream.\n   */\n  static void sunburst(const Entity&amp; entity, const Entity&amp; root,\n      std::ofstream&amp; out);\n\n  /**\n   * Produce data for sunburst chart of code coverage for entity.\n   * \n   * @param entity Entity for which to generate sunburst.\n   * @param root Root entity for the current page. This is used to determine\n   * paths relative to the root.\n   * @param out Output stream.\n   */\n  static void sunburst_data(const Entity&amp; entity, const Entity&amp; root,\n      std::ofstream&amp; out);\n\n  /**\n   * Produce a relative path.\n   */\n  static std::string relative(const std::filesystem::path&amp; path,\n      const std::filesystem::path&amp; base);\n\n  /**\n   * Can the file be written? To be overwritten, the file must either not\n   * exist, or exists but has 'generator: doxide' in its YAML frontmatter.\n   */\n  static bool can_write(const std::filesystem::path&amp; path);\n\n  /**\n   * Produce the YAML frontmatter for an entity.\n   */\n  static std::string frontmatter(const Entity&amp; entity);\n\n  /**\n   * Produce title for an entity.\n   */\n  static std::string title(const Entity&amp; entity);\n\n  /**\n   * Produce brief description for an entity.\n   */\n  static std::string brief(const Entity&amp; entity);\n\n  /**\n   * Reduce to a single line.\n   */\n  static std::string line(const std::string&amp; str);\n\n  /**\n   * Indent lines.\n   */\n  static std::string indent(const std::string&amp; str);\n\n  /**\n   * Sanitize for a string, escaping double quotes and backslashes.\n   */\n  static std::string stringify(const std::string&amp; str);\n\n  /**\n   * Sanitize for HTML, replacing special characters with entities. Also\n   * replaces some characters that might trigger Markdown formatting.\n   */\n  static std::string htmlize(const std::string&amp; str);\n\n  /**\n   * Sanitize for a file name or internal anchor.\n   */\n  static std::string sanitize(const std::string&amp; str);\n\n  /**\n   * Lookup color for given percentage.\n   */\n  static const std::string&amp; color(const double percent);\n\n  /**\n   * Lookup icon for given percentage.\n   */\n  static const std::string&amp; icon(const double percent);\n\n  /**\n   * Convert a list of entities to a list of pointers to entities, optionally\n   * sorting by name.\n   * \n   * @param entities List of entities.\n   * @param sort Sort by name?\n   */\n  static std::list&lt;const Entity*&gt; view(const std::list&lt;Entity&gt;&amp; entities,\n      const bool sort);\n\n  /**\n   * Output directory.\n   */\n  std::filesystem::path output;\n\n  /**\n   * Set of files generated during the last call to generate().\n   */\n  std::unordered_set&lt;std::filesystem::path&gt; files;\n};\n</code></pre>"},{"location":"demo/coverage/src/SourceWatcher.cpp/","title":"SourceWatcher.cpp","text":"<pre><code>#include \"SourceWatcher.hpp\"\n\nSourceWatcher::SourceWatcher(std::list&lt;std::string&gt; patterns): patterns{patterns}{\n  for (auto pattern : patterns){\n    auto paths = glob::rglob(pattern);\n    for (auto&amp; file : paths) {\n      tracked_files[file.string()] = std::filesystem::last_write_time(file);\n    }\n  }\n}\n\nSourceWatcher::SourceWatcher(std::string pattern): SourceWatcher(std::list&lt;std::string&gt;{pattern}){\n  //\n}\n\nstd::tuple&lt;std::unordered_set&lt;std::filesystem::path&gt;,\n           std::unordered_set&lt;std::filesystem::path&gt;,\n           std::unordered_set&lt;std::filesystem::path&gt;&gt; SourceWatcher::diff(){\n  std::unordered_set&lt;std::filesystem::path&gt; added_files;\n  std::unordered_set&lt;std::filesystem::path&gt; modified_files;\n  std::unordered_set&lt;std::filesystem::path&gt; deleted_files = filenames();\n\n  for (auto pattern : patterns){\n    auto paths = glob::rglob(pattern);\n    for(auto&amp; file : paths) {\n      auto last_write_time = std::filesystem::last_write_time(file);\n\n      /* Remove this file from the deleted files set as it still exists*/\n      deleted_files.erase(file.string());\n\n      /* Check file creation and modification */\n      if(! tracked_files.contains(file.string())) {\n        added_files.insert(file.string());\n      } else if(tracked_files[file.string()] != last_write_time) {\n        modified_files.insert(file.string());\n      }\n\n      /* Update the timestamp */\n      tracked_files[file.string()] = last_write_time;\n    }\n  }\n\n  /* Remove deleted files from the tracked_files map */\n  for (auto deleted_file : deleted_files){\n      tracked_files.erase(deleted_file);\n  }\n\n  return {added_files, modified_files, deleted_files};\n}\n\nbool SourceWatcher::changed(){\n  auto [added_files, modified_files, deleted_files] = diff();\n  return !added_files.empty() || !modified_files.empty() || !deleted_files.empty();\n}\n\nstd::unordered_set&lt;std::filesystem::path&gt; SourceWatcher::filenames(){\n  std::unordered_set&lt;std::filesystem::path&gt; filenames;\n  for (auto pairs : tracked_files) {\n    filenames.insert(pairs.first);\n  }\n  return filenames;\n}\n</code></pre>"},{"location":"demo/coverage/src/SourceWatcher.hpp/","title":"SourceWatcher.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n\n#include &lt;filesystem&gt;\n\n/**\n * Source Watcher.\n *\n * Watches for changes of source files. The files to watch are specified by a glob pattern.\n *\n * @ingroup developer\n */\nclass SourceWatcher {\npublic:\n  /**\n   * Constructor for a list of patterns.\n   *\n   * @param patterns\n   */\n  SourceWatcher(std::list&lt;std::string&gt; patterns);\n\n  /**\n   * Constructor for a single pattern.\n   */\n  SourceWatcher(std::string pattern);\n\n  /**\n   * Check if any of the watched files changed since the last call to `changed()` or `diff()`.\n   */\n  bool changed();\n\n  /**\n   * Check if any of the watched files changed since the last call to `changed()` or `diff()`.\n   *\n   * @return A tuple containing sets of added, modified and deleted file paths.\n   */\n  std::tuple&lt;std::unordered_set&lt;std::filesystem::path&gt;,\n             std::unordered_set&lt;std::filesystem::path&gt;,\n             std::unordered_set&lt;std::filesystem::path&gt;&gt; diff();\n\n  /**\n   * The current source files.\n   *\n   */\n  std::unordered_set&lt;std::filesystem::path&gt; filenames();\n\nprivate:\n  /**\n   * The patterns to watch.\n   */\n  std::list&lt;std::string&gt; patterns;\n\n  /**\n   * The tracked file paths and their last modification time.\n   */\n  std::unordered_map&lt;std::filesystem::path, std::filesystem::file_time_type&gt; tracked_files;\n};\n</code></pre>"},{"location":"demo/coverage/src/YAMLNode.cpp/","title":"YAMLNode.cpp","text":"<pre><code>#include \"YAMLNode.hpp\"\n\nbool YAMLNode::has(const key_type&amp; key) const {\n  return isMapping() &amp;&amp; mapping().contains(key);\n}\n\nbool YAMLNode::isValue() const {\n  return std::holds_alternative&lt;value_type&gt;(contents);\n}\n\nbool YAMLNode::isSequence() const {\n  return std::holds_alternative&lt;sequence_type&gt;(contents);\n}\n\nbool YAMLNode::isMapping() const {\n  return std::holds_alternative&lt;mapping_type&gt;(contents);\n}\n\nYAMLNode::value_type&amp; YAMLNode::value() {\n  return std::get&lt;value_type&gt;(contents);\n}\n\nconst YAMLNode::value_type&amp; YAMLNode::value() const {\n  return std::get&lt;value_type&gt;(contents);\n}\n\nYAMLNode::sequence_type&amp; YAMLNode::sequence() {\n  return std::get&lt;sequence_type&gt;(contents);\n}\n\nconst YAMLNode::sequence_type&amp; YAMLNode::sequence() const {\n  return std::get&lt;sequence_type&gt;(contents);\n}\n\nYAMLNode::mapping_type&amp; YAMLNode::mapping() {\n  return std::get&lt;mapping_type&gt;(contents);\n}\n\nconst YAMLNode::mapping_type&amp; YAMLNode::mapping() const {\n  return std::get&lt;mapping_type&gt;(contents);\n}\n\nvoid YAMLNode::set(const variant_type&amp; contents) {\n  this-&gt;contents = contents;\n}\n\nvoid YAMLNode::setSequence() {\n  contents = sequence_type{};\n}\n\nvoid YAMLNode::setMapping() {\n  contents = mapping_type{};\n}\n\nYAMLNode&amp; YAMLNode::push() {\n  return *sequence().emplace_back(std::make_unique&lt;YAMLNode&gt;());\n}\n\nYAMLNode&amp; YAMLNode::insert(const key_type&amp; key) {\n  return *mapping().insert(std::make_pair(key,\n      std::make_unique&lt;YAMLNode&gt;())).first-&gt;second;\n}\n</code></pre>"},{"location":"demo/coverage/src/YAMLNode.hpp/","title":"YAMLNode.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n\n/**\n * Node in a YAML document.\n * \n * @ingroup developer\n */\nclass YAMLNode {\npublic:\n  using key_type = std::string;\n  using value_type = std::string;\n  using sequence_type = std::list&lt;std::shared_ptr&lt;YAMLNode&gt;&gt;;\n  using mapping_type = std::unordered_map&lt;key_type,std::shared_ptr&lt;YAMLNode&gt;&gt;;\n  using variant_type = std::variant&lt;value_type,sequence_type,mapping_type&gt;;\n\n  /**\n   * Does this have a given key?\n   */\n  bool has(const key_type&amp; key) const;\n\n  /**\n   * Is this a value?\n   */\n  bool isValue() const;\n\n  /**\n   * Is there a value at a given path?\n   * \n   * @param key Key.\n   * @param keys... Keys.\n   */\n  template&lt;class... Args&gt;\n  bool isValue(const key_type&amp; key, Args&amp;&amp;... keys) const {\n    return has(key) &amp;&amp;\n        mapping().at(key)-&gt;isValue(std::forward&lt;Args&gt;(keys)...);\n  }\n\n  /**\n   * Is this a sequence?\n   */\n  bool isSequence() const;\n\n  /**\n   * Is there a sequence at a given path?\n   * \n   * @param key Key.\n   * @param keys... Keys.\n   */\n  template&lt;class... Args&gt;\n  bool isSequence(const key_type&amp; key, Args&amp;&amp;... keys) const {\n    return has(key) &amp;&amp;\n        mapping().at(key)-&gt;isSequence(std::forward&lt;Args&gt;(keys)...);\n  }\n\n  /**\n   * Is this a mapping?\n   */\n  bool isMapping() const;\n\n  /**\n   * Is there a mapping at a given path?\n   * \n   * @param key Key.\n   * @param keys... Keys.\n   */\n  template&lt;class... Args&gt;\n  bool isMapping(const key_type&amp; key, Args&amp;&amp;... keys) const {\n    return has(key) &amp;&amp;\n        mapping().at(key)-&gt;isMapping(std::forward&lt;Args&gt;(keys)...);\n  }\n\n  /**\n   * Get this as a value.\n   */\n  value_type&amp; value();\n\n  /**\n   * Get this as a value.\n   */\n  const value_type&amp; value() const;\n\n  /**\n   * Get the value at a given path.\n   * \n   * @param key Key.\n   * @param keys... Keys.\n   * \n   * @return The value.\n   */\n  template&lt;class... Args&gt;\n  value_type&amp; value(const key_type&amp; key, Args&amp;&amp;... keys) {\n    return mapping().at(key)-&gt;value(std::forward&lt;Args&gt;(keys)...);\n  }\n\n  /**\n   * Get the value at a given path.\n   * \n   * @param key Key.\n   * @param keys... Keys.\n   * \n   * @return The value.\n   */\n  template&lt;class... Args&gt;\n  const value_type&amp; value(const key_type&amp; key, Args&amp;&amp;... keys) const {\n    return mapping().at(key)-&gt;value(std::forward&lt;Args&gt;(keys)...);\n  }\n\n  /**\n   * Get this as a sequence.\n   */\n  sequence_type&amp; sequence();\n\n  /**\n   * Get this as a sequence.\n   */\n  const sequence_type&amp; sequence() const;\n\n  /**\n   * Get the sequence at a given path.\n   * \n   * @param key Key.\n   * @param keys... Keys.\n   * \n   * @return The sequence.\n   */\n  template&lt;class... Args&gt;\n  sequence_type&amp; sequence(const key_type&amp; key, Args&amp;&amp;... keys) {\n    return mapping().at(key)-&gt;sequence(std::forward&lt;Args&gt;(keys)...);\n  }\n\n  /**\n   * Get the sequence at a given path.\n   * \n   * @param key Key.\n   * @param keys... Keys.\n   * \n   * @return The sequence.\n   */\n  template&lt;class... Args&gt;\n  const sequence_type&amp; sequence(const key_type&amp; key, Args&amp;&amp;... keys) const {\n    return mapping().at(key)-&gt;sequence(std::forward&lt;Args&gt;(keys)...);\n  }\n\n  /**\n   * Get this as a mapping.\n   */\n  mapping_type&amp; mapping();\n\n  /**\n   * Get this as a mapping.\n   */\n  const mapping_type&amp; mapping() const;\n\n  /**\n   * Get the mapping at a given path.\n   * \n   * @param key Key.\n   * @param keys... Keys.\n   * \n   * @return The mapping.\n   */\n  template&lt;class... Args&gt;\n  mapping_type&amp; mapping(const key_type&amp; key, Args&amp;&amp;... keys) {\n    return mapping().at(key)-&gt;mapping(std::forward&lt;Args&gt;(keys)...);\n  }\n\n  /**\n   * Get the mapping at a given path.\n   * \n   * @param key Key.\n   * @param keys... Keys.\n   * \n   * @return The mapping.\n   */\n  template&lt;class... Args&gt;\n  const mapping_type&amp; mapping(const key_type&amp; key, Args&amp;&amp;... keys) const {\n    return mapping().at(key)-&gt;mapping(std::forward&lt;Args&gt;(keys)...);\n  }\n\n  /**\n   * Set the value.\n   */\n  void set(const variant_type&amp; contents);\n\n  /**\n   * Set as a sequence.\n   */\n  void setSequence();\n\n  /**\n   * Set as a mapping.\n   */\n  void setMapping();\n\n  /**\n   * For a sequence, push an uninitialized node onto the end and return it.\n   */\n  YAMLNode&amp; push();\n\n  /**\n   * For a mapping, insert a key with an uninitialized value and return the\n   * value.\n   */\n  YAMLNode&amp; insert(const key_type&amp; key);\n\nprivate:\n  /**\n   * Contents.\n   */\n  variant_type contents;\n};\n</code></pre>"},{"location":"demo/coverage/src/YAMLParser.cpp/","title":"YAMLParser.cpp","text":"<pre><code>#include \"YAMLParser.hpp\"\n\nYAMLParser::YAMLParser() {\n  yaml_parser_initialize(&amp;parser);\n}\n\nYAMLParser::~YAMLParser() {\n  yaml_parser_delete(&amp;parser);\n}\n\nYAMLNode YAMLParser::parse(const std::filesystem::path&amp; filename) {\n  YAMLNode root;\n  FILE* file = fopen(filename.string().c_str(), \"r\");\n  if (!file) {\n    throw std::runtime_error(\"could not read file \" + filename.string());\n  }\n\n  yaml_parser_set_input_file(&amp;parser, file);\n  bool done = false;\n  try {\n    while (!done) {\n      if (!yaml_parser_parse(&amp;parser, &amp;event)) {\n        throw std::runtime_error(\"YAML syntax error in file \" +\n            filename.string());\n      }\n      if (event.type == YAML_SEQUENCE_START_EVENT) {\n        parseSequence(filename, root);\n      } else if (event.type == YAML_MAPPING_START_EVENT) {\n        parseMapping(filename, root);\n      } else if (event.type == YAML_DOCUMENT_END_EVENT ||\n          event.type == YAML_STREAM_END_EVENT) {\n        done = true;\n        yaml_event_delete(&amp;event);\n      } else {\n        yaml_event_delete(&amp;event);\n      }\n    }\n  } catch (const std::runtime_error&amp; e) {\n    /* close file before propagating exception */\n    fclose(file);\n    throw e;\n  }\n  fclose(file);\n\n  return root;\n}\n\nvoid YAMLParser::parseMapping(const std::filesystem::path&amp; filename,\n    YAMLNode&amp; node) {\n  yaml_event_delete(&amp;event);\n  node.setMapping();\n  int done = 0;\n  while (!done) {\n    /* read one name/value pair on each iteration */\n    if (!yaml_parser_parse(&amp;parser, &amp;event)) {\n      throw std::runtime_error(\"YAML syntax error in file \" +\n          filename.string());\n    }\n    if (event.type == YAML_SCALAR_EVENT) {\n      /* key */\n      auto data = (char*)event.data.scalar.value;\n      auto length = event.data.scalar.length;\n      auto key = std::string{data, length};\n      yaml_event_delete(&amp;event);\n\n      /* value */\n      if (!yaml_parser_parse(&amp;parser, &amp;event)) {\n        throw std::runtime_error(\"YAML syntax error in file \" +\n            filename.string());\n      }\n      if (event.type == YAML_SCALAR_EVENT) {\n        parseValue(filename, node.insert(key));\n      } else if (event.type == YAML_SEQUENCE_START_EVENT) {\n        parseSequence(filename, node.insert(key));\n      } else if (event.type == YAML_MAPPING_START_EVENT) {\n        parseMapping(filename, node.insert(key));\n      } else {\n        yaml_event_delete(&amp;event);\n      }\n    } else {\n      done = event.type == YAML_MAPPING_END_EVENT;\n      yaml_event_delete(&amp;event);\n    }\n  }\n}\n\nvoid YAMLParser::parseSequence(const std::filesystem::path&amp; filename,\n    YAMLNode&amp; node) {\n  yaml_event_delete(&amp;event);\n  node.setSequence();\n  int done = 0;\n  while (!done) {\n    if (!yaml_parser_parse(&amp;parser, &amp;event)) {\n      throw std::runtime_error(\"YAML syntax error in file \" +\n          filename.string());\n    }\n    if (event.type == YAML_SCALAR_EVENT) {\n      parseValue(filename, node.push());\n    } else if (event.type == YAML_SEQUENCE_START_EVENT) {\n      parseSequence(filename, node.push());\n    } else if (event.type == YAML_MAPPING_START_EVENT) {\n      parseMapping(filename, node.push());\n    } else {\n      done = event.type == YAML_SEQUENCE_END_EVENT;\n      yaml_event_delete(&amp;event);\n    }\n  }\n}\n\nvoid YAMLParser::parseValue(const std::filesystem::path&amp; filename,\n    YAMLNode&amp; node) {\n  auto data = (char*)event.data.scalar.value;\n  auto length = event.data.scalar.length;\n  node.set(std::string(data, length));\n  yaml_event_delete(&amp;event);\n}\n</code></pre>"},{"location":"demo/coverage/src/YAMLParser.hpp/","title":"YAMLParser.hpp","text":"<pre><code>#pragma once\n\n#include \"doxide.hpp\"\n#include \"YAMLNode.hpp\"\n\n/**\n * Parser for YAML config files and YAML frontmatter of Markdown files. Also\n * works for JSON, as YAML is nowadays a superset of JSON.\n * \n * @ingroup developer\n */\nclass YAMLParser {\npublic:\n  /**\n   * Constructor.\n   *\n   * @param filename File name.\n   */\n  YAMLParser();\n\n  /**\n   * Destructor.\n   */\n  ~YAMLParser();\n\n  /**\n   * Parse the file.\n   * \n   * @return The contents of the file.\n   */\n  YAMLNode parse(const std::filesystem::path&amp; filename);\n\nprivate:\n  void parseMapping(const std::filesystem::path&amp; filename, YAMLNode&amp; node);\n  void parseSequence(const std::filesystem::path&amp; filename, YAMLNode&amp; node);\n  void parseValue(const std::filesystem::path&amp; filename, YAMLNode&amp; node);\n\n  /**\n   * LibYAML parser.\n   */\n  yaml_parser_t parser;\n\n  /**\n   * LibYAML event.\n   */\n  yaml_event_t event;\n};\n</code></pre>"},{"location":"demo/coverage/src/doxide.cpp/","title":"doxide.cpp","text":"<pre><code>#include \"Driver.hpp\"\n#include \"config.h\"\n\nvoid write_file(const std::string&amp; contents,\n    const std::filesystem::path&amp; dst) {\n  if (dst.has_parent_path()) {\n    std::filesystem::create_directories(dst.parent_path());\n  }\n  std::fstream out(dst, std::ios::out);\n  if (!out.is_open()) {\n    throw std::runtime_error(\"could not write file \" + dst.string());\n  }\n  out &lt;&lt; contents;\n}\n\nvoid write_file_prompt(const std::string&amp; contents,\n    const std::filesystem::path&amp; dst) {\n  if (dst.has_parent_path()) {\n    std::filesystem::create_directories(dst.parent_path());\n  }\n  if (std::filesystem::exists(dst)) {\n    std::cout &lt;&lt; dst.string() &lt;&lt; \" already exists, overwrite? [y/N] \";\n    std::string ans;\n    std::getline(std::cin, ans);\n    if (ans.length() &gt; 0 &amp;&amp; (ans[0] == 'y' || ans[0] == 'Y')) {\n      write_file(contents, dst);\n    }\n  } else {\n    write_file(contents, dst);\n  }\n}\n\nstd::string gulp(const std::filesystem::path&amp; src) {\n  std::string contents;\n  std::ifstream in(src);\n  if (!in.is_open()) {\n    throw std::runtime_error(\"could not read file \" + src.string());\n  }\n  char buffer[8192];\n  while (in.read(buffer, sizeof(buffer))) {\n    contents.append(buffer, sizeof(buffer));\n  }\n  contents.append(buffer, in.gcount());\n  return contents;\n}\n\nint main(int argc, char** argv) {\n  Driver driver;\n  CLI::App app{\"Modern documentation for modern C++.\\n\"};\n  app.get_formatter()-&gt;column_width(30);\n  app.add_option(\"--title\",\n      driver.title,\n      \"Main page title.\");\n  app.add_option(\"--description\",\n      driver.description,\n      \"Main page description.\");\n  app.add_option(\"--output\", driver.output,\n      \"Output directory.\");\n  app.add_option(\"--coverage\", driver.coverage,\n      \"Code coverage file (.gcov or .json).\");\n  app.set_version_flag(\"--version,-v\", PACKAGE_VERSION, \"Doxide version.\");\n  app.add_subcommand(\"init\",\n      \"Initialize configuration files.\")-&gt;\n      fallthrough()-&gt;\n      callback([&amp;]() { driver.init(); });\n  app.add_subcommand(\"build\",\n      \"Build documentation in output directory.\")-&gt;\n      fallthrough()-&gt;\n      callback([&amp;]() { driver.build(); });\n  app.add_subcommand(\"watch\",\n      \"Watch the documentation's source files and rebuild it on changes.\")-&gt;\n      fallthrough()-&gt;\n      callback([&amp;]() { driver.watch(); });\n  app.add_subcommand(\"clean\",\n      \"Clean output directory.\")-&gt;\n      fallthrough()-&gt;\n      callback([&amp;]() { driver.clean(); });\n  app.add_subcommand(\"cover\",\n      \"Output code coverage data to stdout in JSON format.\")-&gt;\n      fallthrough()-&gt;\n      callback([&amp;]() { driver.cover(); });\n  app.require_subcommand(1);\n  CLI11_PARSE(app, argc, argv);\n}\n</code></pre>"},{"location":"demo/coverage/src/doxide.hpp/","title":"doxide.hpp","text":"<pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;regex&gt;\n#include &lt;stack&gt;\n#include &lt;list&gt;\n#include &lt;unordered_set&gt;\n#include &lt;unordered_map&gt;\n#include &lt;algorithm&gt;\n#include &lt;filesystem&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;iomanip&gt;\n#include &lt;variant&gt;\n#include &lt;regex&gt;\n\n#include &lt;cassert&gt;\n\n#include &lt;yaml.h&gt;\n#include &lt;tree_sitter/api.h&gt;\n#include &lt;glob/glob.hpp&gt;\n#include &lt;CLI/CLI.hpp&gt;\n\n/**\n * Print a warning message.\n * \n * @ingroup developer\n */\n#define warn(msg) \\\n    std::cerr &lt;&lt; \"warning: \" &lt;&lt; msg &lt;&lt; std::endl;\n\n/**\n * Print an error message and exit.\n * \n * @ingroup developer\n */\n#define error(msg) \\\n    std::cerr &lt;&lt; \"error: \" &lt;&lt; msg &lt;&lt; std::endl; \\\n    exit(EXIT_FAILURE);\n\n/**\n * Regular expression configuration.\n * \n * @ingroup developer\n */\nstatic const std::regex_constants::syntax_option_type regex_flags =\n    std::regex_constants::ECMAScript|std::regex_constants::optimize;\n\n/**\n * Write a whole file.\n * \n * @ingroup developer\n */\nvoid write_file(const std::string&amp; contents, const std::filesystem::path&amp; dst);\n\n/**\n * Write a whole file, prompting to confirm overwrite if it already exists.\n * \n * @ingroup developer\n */\nvoid write_file_prompt(const std::string&amp; contents, const std::filesystem::path&amp; dst);\n\n/**\n * Read in a whole file.\n * \n * @ingroup developer\n */\nstd::string gulp(const std::filesystem::path&amp; src);\n\n/**\n * Tree-sitter C++ language handle.\n * \n * @ingroup developer\n */\nextern \"C\" const TSLanguage* tree_sitter_cpp();\n\n/**\n * Tree-sitter CUDA language handle.\n * \n * @ingroup developer\n */\nextern \"C\" const TSLanguage* tree_sitter_cuda();\n</code></pre>"},{"location":"demo/developer/","title":"Developer","text":"<p>Doxide's own source code documentation.</p>"},{"location":"demo/developer/#types","title":"Types","text":"Name Description CppParser C++ source parser. Doc Documentation of an entity. DocToken Token. DocTokenType Documentation comment token types. DocTokenizer Documentation comment tokenizer. Driver Driver for running commands Entity Entity in a C++ source file, e.g. variable, function, class, etc. EntityType Entity types. GcovCounter Gcov processor for coverage data. JSONCounter JSON processor for coverage data following gcov/gcovr schema. JSONGenerator JSON generator for coverage data following gcov/gcovr schema. MarkdownGenerator Markdown generator. SourceWatcher Source Watcher. YAMLNode Node in a YAML document. YAMLParser Parser for YAML config files and YAML frontmatter of Markdown files."},{"location":"demo/developer/#macros","title":"Macros","text":"Name Description error Print an error message and exit. warn Print a warning message."},{"location":"demo/developer/#variables","title":"Variables","text":"Name Description init_docs_javascripts_mathjax_js Contents of initial <code>docs/javascripts/mathjax.js</code> file. init_docs_javascripts_tablesort_js Contents of initial <code>docs/javascripts/tablesort.js</code> file. init_docs_overrides_partials_copyright_html Contents of initial <code>docs/overrides/partials/copyright.html</code> file. init_docs_stylesheets_doxide_css Contents of initial <code>docs/stylesheets/doxide.css</code> file. init_doxide_yaml Contents of initial <code>doxide.yaml</code> file. init_mkdocs_yaml Contents of initial <code>mkdocs.yaml</code> file. query_cpp Query for entities in C++ sources. query_cpp_exclude Query for entities to explicitly exclude from  line counts in C++ sources. query_cpp_include Query for entities to explicitly include in line counts in C++ sources. regex_flags Regular expression configuration. regexes Documentation comment token patterns."},{"location":"demo/developer/#functions","title":"Functions","text":"Name Description gulp Read in a whole file. tree_sitter_cpp Tree-sitter C++ language handle. tree_sitter_cuda Tree-sitter CUDA language handle. write_file Write a whole file. write_file_prompt Write a whole file, prompting to confirm overwrite if it already exists."},{"location":"demo/developer/#macro-details","title":"Macro Details","text":""},{"location":"demo/developer/#error","title":"error","text":"<p>#define error(msg)</p> <p>Print an error message and exit.</p>"},{"location":"demo/developer/#warn","title":"warn","text":"<p>#define warn(msg)</p> <p>Print a warning message.</p>"},{"location":"demo/developer/#variable-details","title":"Variable Details","text":""},{"location":"demo/developer/#init_docs_javascripts_mathjax_js","title":"init_docs_javascripts_mathjax_js","text":"<p>static const char* init_docs_javascripts_mathjax_js</p> <p>Contents of initial <code>docs/javascripts/mathjax.js</code> file.</p>"},{"location":"demo/developer/#init_docs_javascripts_tablesort_js","title":"init_docs_javascripts_tablesort_js","text":"<p>static const char* init_docs_javascripts_tablesort_js</p> <p>Contents of initial <code>docs/javascripts/tablesort.js</code> file.</p>"},{"location":"demo/developer/#init_docs_overrides_partials_copyright_html","title":"init_docs_overrides_partials_copyright_html","text":"<p>static const char* init_docs_overrides_partials_copyright_html</p> <p>Contents of initial <code>docs/overrides/partials/copyright.html</code> file.</p>"},{"location":"demo/developer/#init_docs_stylesheets_doxide_css","title":"init_docs_stylesheets_doxide_css","text":"<p>static const char* init_docs_stylesheets_doxide_css</p> <p>Contents of initial <code>docs/stylesheets/doxide.css</code> file.</p>"},{"location":"demo/developer/#init_doxide_yaml","title":"init_doxide_yaml","text":"<p>static const char* init_doxide_yaml</p> <p>Contents of initial <code>doxide.yaml</code> file.</p>"},{"location":"demo/developer/#init_mkdocs_yaml","title":"init_mkdocs_yaml","text":"<p>static const char* init_mkdocs_yaml</p> <p>Contents of initial <code>mkdocs.yaml</code> file.</p>"},{"location":"demo/developer/#query_cpp","title":"query_cpp","text":"<p>static const char* query_cpp</p> <p>Query for entities in C++ sources.</p>"},{"location":"demo/developer/#query_cpp_exclude","title":"query_cpp_exclude","text":"<p>static const char* query_cpp_exclude</p> <p>Query for entities to explicitly exclude from  line counts in C++ sources.</p>"},{"location":"demo/developer/#query_cpp_include","title":"query_cpp_include","text":"<p>static const char* query_cpp_include</p> <p>Query for entities to explicitly include in line counts in C++ sources.</p>"},{"location":"demo/developer/#regex_flags","title":"regex_flags","text":"<p>static const std::regex_constants::syntax_option_type regex_flags</p> <p>Regular expression configuration.</p>"},{"location":"demo/developer/#regexes","title":"regexes","text":"<p>static auto regexes</p> <p>Documentation comment token patterns. Order is important, as a match to an earlier pattern precludes a match to a later.</p>"},{"location":"demo/developer/#function-details","title":"Function Details","text":""},{"location":"demo/developer/#gulp","title":"gulp","text":"<p>std::string gulp(const std::filesystem::path&amp; src)</p> <p>Read in a whole file.</p>"},{"location":"demo/developer/#tree_sitter_cpp","title":"tree_sitter_cpp","text":"<p>const TSLanguage* tree_sitter_cpp()</p> <p>Tree-sitter C++ language handle.</p>"},{"location":"demo/developer/#tree_sitter_cuda","title":"tree_sitter_cuda","text":"<p>const TSLanguage* tree_sitter_cuda()</p> <p>Tree-sitter CUDA language handle.</p>"},{"location":"demo/developer/#write_file","title":"write_file","text":"<p>void write_file(const std::string&amp; contents, const std::filesystem::path&amp; dst)</p> <p>Write a whole file.</p>"},{"location":"demo/developer/#write_file_prompt","title":"write_file_prompt","text":"<p>void write_file_prompt(const std::string&amp; contents, const std::filesystem::path&amp; dst)</p> <p>Write a whole file, prompting to confirm overwrite if it already exists.</p>"},{"location":"demo/developer/CppParser/","title":"CppParser","text":"<p>class CppParser</p> <p>C++ source parser.</p>"},{"location":"demo/developer/CppParser/#variables","title":"Variables","text":"Name Description entities Stack of entities while parsing. starts Stack of start bytes, corresponding to <code>entities</code>, while parsing. ends Stack of end bytes, corresponding to <code>entities</code>, while parsing. parser C++ parser. query C++ entities query. query_exclude C++ exclusions query. query_include C++ inclusions query."},{"location":"demo/developer/CppParser/#functions","title":"Functions","text":"Name Description CppParser Constructor. ~CppParser Destructor. parse Parse C++ source. push Push onto the stack. pop Pop the stack down to the parent of an entity, according to its byte range. preprocess Preprocess C++ source, replacing preprocessor macros as defined in the config file and attempting to recover from any parse errors. report Report errors after preprocessing."},{"location":"demo/developer/CppParser/#variable-details","title":"Variable Details","text":""},{"location":"demo/developer/CppParser/#ends","title":"ends","text":"<p>std::list&lt;uint32_t&gt; ends</p> <p>Stack of end bytes, corresponding to <code>entities</code>, while parsing.</p>"},{"location":"demo/developer/CppParser/#entities","title":"entities","text":"<p>std::list&lt;Entity&gt; entities</p> <p>Stack of entities while parsing.</p>"},{"location":"demo/developer/CppParser/#parser","title":"parser","text":"<p>TSParser* parser</p> <p>C++ parser.</p>"},{"location":"demo/developer/CppParser/#query","title":"query","text":"<p>TSQuery* query</p> <p>C++ entities query.</p>"},{"location":"demo/developer/CppParser/#query_exclude","title":"query_exclude","text":"<p>TSQuery* query_exclude</p> <p>C++ exclusions query.</p>"},{"location":"demo/developer/CppParser/#query_include","title":"query_include","text":"<p>TSQuery* query_include</p> <p>C++ inclusions query.</p>"},{"location":"demo/developer/CppParser/#starts","title":"starts","text":"<p>std::list&lt;uint32_t&gt; starts</p> <p>Stack of start bytes, corresponding to <code>entities</code>, while parsing.</p>"},{"location":"demo/developer/CppParser/#function-details","title":"Function Details","text":""},{"location":"demo/developer/CppParser/#cppparser_1","title":"CppParser","text":"<p>CppParser()</p> <p>Constructor.</p>"},{"location":"demo/developer/CppParser/#parse","title":"parse","text":"<p>void parse(const std::filesystem::path&amp; filename, const std::unordered_map&lt;std::string,std::string&gt;&amp; defines, Entity&amp; root)</p> <p>Parse C++ source.</p> <code>file</code> C++ source file name. <code>defines</code> Macro definitions. <code>root</code> Root entity."},{"location":"demo/developer/CppParser/#pop","title":"pop","text":"<p>Entity&amp; pop(const uint32_t start = 0, const uint32_t end = 0)</p> <p>Pop the stack down to the parent of an entity, according to its byte     range.</p> <code>start</code> Start byte of range. <code>end</code> End byte of range. Return The parent. <p>If both <code>start</code> and <code>end</code> are zero, this is interpreting as popping the stack down to the root node and returning it.</p>"},{"location":"demo/developer/CppParser/#preprocess","title":"preprocess","text":"<p>std::string preprocess(const std::filesystem::path&amp; file, const std::unordered_map&lt;std::string,std::string&gt;&amp; defines)</p> <p>Preprocess C++ source, replacing preprocessor macros as defined in the config file and attempting to recover from any parse errors. This is silent and does not report uncorrectable errors, these are reported later.</p> <code>file</code> C++ source file name. <code>defines</code> Macro definitions. Return Preprocessed source."},{"location":"demo/developer/CppParser/#push","title":"push","text":"<p>void push(Entity&amp;&amp; entity, const uint32_t start, const uint32_t end)</p> <p>Push onto the stack.</p> <code>entity</code> Entity to push. <code>start</code> Start byte of range. <code>end</code> End byte of range."},{"location":"demo/developer/CppParser/#report","title":"report","text":"<p>void report(const std::filesystem::path&amp; file, const std::string&amp; in, TSTree* tree)</p> <p>Report errors after preprocessing.</p> <code>file</code> C++ source file name. <code>in</code> Preprocessed source. <code>tree</code> Parse tree for file."},{"location":"demo/developer/CppParser/#cppparser_2","title":"~CppParser","text":"<p>~CppParser()</p> <p>Destructor.</p>"},{"location":"demo/developer/Doc/","title":"Doc","text":"<p>struct Doc</p> <p>Documentation of an entity.</p>"},{"location":"demo/developer/Doc/#variables","title":"Variables","text":"Name Description docs Content of the documentation. ingroup Group to which the entity belongs, obtained from  the documentation comment. open Opening token, used to determine the type of comment. indent Current indent level of the documentation comment for this entity. hide Hide the associated entity?"},{"location":"demo/developer/Doc/#functions","title":"Functions","text":"Name Description Doc Constructor."},{"location":"demo/developer/Doc/#variable-details","title":"Variable Details","text":""},{"location":"demo/developer/Doc/#docs","title":"docs","text":"<p>std::string docs</p> <p>Content of the documentation.</p>"},{"location":"demo/developer/Doc/#hide","title":"hide","text":"<p>bool hide</p> <p>Hide the associated entity?</p>"},{"location":"demo/developer/Doc/#indent","title":"indent","text":"<p>int indent</p> <p>Current indent level of the documentation comment for this entity. This     is used for tracking indenting across multiple end-of-line comments, for     example following a @note command, each following line should be     indented until the end of the paragraph.</p>"},{"location":"demo/developer/Doc/#ingroup","title":"ingroup","text":"<p>std::string ingroup</p> <p>Group to which the entity belongs, obtained from  the     documentation comment.</p>"},{"location":"demo/developer/Doc/#open","title":"open","text":"<p>DocToken open</p> <p>Opening token, used to determine the type of comment.</p>"},{"location":"demo/developer/Doc/#function-details","title":"Function Details","text":""},{"location":"demo/developer/Doc/#doc_1","title":"Doc","text":"<p>Doc(const std::string_view comment, const int init_indent)</p> <p>Constructor.</p> <code>comment</code> Comment from which to populate documentation. <code>init_indent</code> Initial indent level."},{"location":"demo/developer/DocToken/","title":"DocToken","text":"<p>struct DocToken</p> <p>Token.</p> <p>A token is only valid for the lifetime of the Tokenizer that produced it, as it contains a reference to a substring of the source file.</p>"},{"location":"demo/developer/DocToken/#variables","title":"Variables","text":"Name Description type Token type. value Iterator to first character."},{"location":"demo/developer/DocToken/#functions","title":"Functions","text":"Name Description DocToken Constructor. str Get token as string. substr Get substring of the token as a string."},{"location":"demo/developer/DocToken/#variable-details","title":"Variable Details","text":""},{"location":"demo/developer/DocToken/#type","title":"type","text":"<p>DocTokenType type</p> <p>Token type.</p>"},{"location":"demo/developer/DocToken/#value","title":"value","text":"<p>std::string_view value</p> <p>Iterator to first character.</p>"},{"location":"demo/developer/DocToken/#function-details","title":"Function Details","text":""},{"location":"demo/developer/DocToken/#doctoken_1","title":"DocToken","text":"<p>DocToken(const DocTokenType type = NONE, std::string_view value = std::string_view())</p> <p>Constructor.</p> <code>type</code> Token type. <code>value</code> Token value."},{"location":"demo/developer/DocToken/#str","title":"str","text":"<p>std::string_view str() const</p> <p>Get token as string.</p>"},{"location":"demo/developer/DocToken/#substr","title":"substr","text":"<p>std::string_view substr(size_t pos = 0) const</p> <p>Get substring of the token as a string.</p> <code>pos</code> Position of the first character."},{"location":"demo/developer/DocTokenType/","title":"DocTokenType","text":"<p>enum DocTokenType : int</p> <p>Documentation comment token types. Closing delimiters must be one shift left of their opening counterparts.</p>"},{"location":"demo/developer/DocTokenizer/","title":"DocTokenizer","text":"<p>class DocTokenizer</p> <p>Documentation comment tokenizer.</p>"},{"location":"demo/developer/DocTokenizer/#variables","title":"Variables","text":"Name Description iter Iterator over source. end End of source."},{"location":"demo/developer/DocTokenizer/#functions","title":"Functions","text":"Name Description DocTokenizer Constructor. next Get the next token. consume Consume tokens until stopping criterion."},{"location":"demo/developer/DocTokenizer/#variable-details","title":"Variable Details","text":""},{"location":"demo/developer/DocTokenizer/#end","title":"end","text":"<p>std::string_view::const_iterator end</p> <p>End of source.</p>"},{"location":"demo/developer/DocTokenizer/#iter","title":"iter","text":"<p>std::string_view::const_iterator iter</p> <p>Iterator over source.</p>"},{"location":"demo/developer/DocTokenizer/#function-details","title":"Function Details","text":""},{"location":"demo/developer/DocTokenizer/#doctokenizer_1","title":"DocTokenizer","text":"<p>DocTokenizer(const std::string_view&amp; source)</p> <p>Constructor.</p> <code>comment</code> Comment to tokenize."},{"location":"demo/developer/DocTokenizer/#consume","title":"consume","text":"<p>DocToken consume(const int stop = ANY)</p> <p>Consume tokens until stopping criterion.</p> <code>stop</code> Bitmask giving the token types on which to stop and return. Return Last token consumed. <p>Tokens are consumed until one is encountered with a type in <code>stop,</code> which is then returned. If <code>stop</code> is <code>ANY</code> then the next token is returned.</p>"},{"location":"demo/developer/DocTokenizer/#next","title":"next","text":"<p>DocToken next()</p> <p>Get the next token.</p> Return Next token. <p>The token is only valid for the lifetime of the DocTokenizer, as it contains a reference to a substring of the source file. If no tokens remain (i.e. the end of the file is reached), a token with a type of <code>NONE</code> is returned.</p>"},{"location":"demo/developer/Driver/","title":"Driver","text":"<p>class Driver</p> <p>Driver for running commands</p>"},{"location":"demo/developer/Driver/#variables","title":"Variables","text":"Name Description title Title. description Description. coverage Coverage file. output Output directory. root Root entity. config_file Configuration file path. files_patterns Files patterns. defines Macro definitions. filenames Files."},{"location":"demo/developer/Driver/#functions","title":"Functions","text":"Name Description Driver Constructor. init Create a new configuration file. build Build documentation. watch Watch and build documentation on changes. cover Output line coverage information. clean Clean documentation. config Read in the configuration file. parse Parse files. count Count line coverage. groups Recursively read groups from the configuration file."},{"location":"demo/developer/Driver/#variable-details","title":"Variable Details","text":""},{"location":"demo/developer/Driver/#config_file","title":"config_file","text":"<p>std::filesystem::path config_file</p> <p>Configuration file path.</p>"},{"location":"demo/developer/Driver/#coverage","title":"coverage","text":"<p>std::filesystem::path coverage</p> <p>Coverage file.</p>"},{"location":"demo/developer/Driver/#defines","title":"defines","text":"<p>std::unordered_map&lt;std::string,std::string&gt; defines</p> <p>Macro definitions.</p>"},{"location":"demo/developer/Driver/#description","title":"description","text":"<p>std::string description</p> <p>Description.</p>"},{"location":"demo/developer/Driver/#filenames","title":"filenames","text":"<p>std::unordered_set&lt;std::filesystem::path&gt; filenames</p> <p>Files.</p>"},{"location":"demo/developer/Driver/#files_patterns","title":"files_patterns","text":"<p>std::list&lt;std::string&gt; files_patterns</p> <p>Files patterns.</p>"},{"location":"demo/developer/Driver/#output","title":"output","text":"<p>std::filesystem::path output</p> <p>Output directory.</p>"},{"location":"demo/developer/Driver/#root","title":"root","text":"<p>Entity root</p> <p>Root entity.</p>"},{"location":"demo/developer/Driver/#title","title":"title","text":"<p>std::string title</p> <p>Title.</p>"},{"location":"demo/developer/Driver/#function-details","title":"Function Details","text":""},{"location":"demo/developer/Driver/#driver_1","title":"Driver","text":"<p>Driver()</p> <p>Constructor.</p>"},{"location":"demo/developer/Driver/#build","title":"build","text":"<p>void build()</p> <p>Build documentation.</p>"},{"location":"demo/developer/Driver/#clean","title":"clean","text":"<p>void clean()</p> <p>Clean documentation.</p>"},{"location":"demo/developer/Driver/#config","title":"config","text":"<p>void config()</p> <p>Read in the configuration file.</p>"},{"location":"demo/developer/Driver/#count","title":"count","text":"<p>void count()</p> <p>Count line coverage.</p>"},{"location":"demo/developer/Driver/#cover","title":"cover","text":"<p>void cover()</p> <p>Output line coverage information.</p>"},{"location":"demo/developer/Driver/#groups","title":"groups","text":"<p>static void groups(YAMLNode&amp; parentNode, Entity&amp; parentEntity)</p> <p>Recursively read groups from the configuration file.</p>"},{"location":"demo/developer/Driver/#init","title":"init","text":"<p>void init()</p> <p>Create a new configuration file.</p>"},{"location":"demo/developer/Driver/#parse","title":"parse","text":"<p>void parse()</p> <p>Parse files.</p>"},{"location":"demo/developer/Driver/#watch","title":"watch","text":"<p>void watch()</p> <p>Watch and build documentation on changes.</p>"},{"location":"demo/developer/Entity/","title":"Entity","text":"<p>struct Entity</p> <p>Entity in a C++ source file, e.g. variable, function, class, etc.</p>"},{"location":"demo/developer/Entity/#type-aliases","title":"Type Aliases","text":"Name Description list_type Child entities are stored in a list, rather than map by name, to preserve declaration order."},{"location":"demo/developer/Entity/#variables","title":"Variables","text":"Name Description namespaces Child namespaces. groups Child groups. types Child types. typedefs Child typedefs and type aliases. concepts Child concepts. variables Child variables. functions Child functions. operators Child operators. enums Child enumerators. macros Child macros. dirs Child directories. files Child files. name Entity name (e.g. name of variable, function, class). For a file or directory this is the full path. decl Entity declaration (e.g. function signature). For a file this is its full contents. docs Entity documentation. title Entity title. brief Alternative brief description. ingroup Group to which this belongs. path Path of source file. start_line Starting line in the source file. end_line Ending line in the source file. line_counts For a file only, execution counts for lines. lines_included Number of lines included in coverage counts. lines_covered Number of lines covered in coverage counts. type Entity type. visible Is this node visible? hide Hide this node?"},{"location":"demo/developer/Entity/#functions","title":"Functions","text":"Name Description Entity Constructor. add Add child entity. merge Merge the children of another entity into this one. exists Does a file exist of the given name? get Get a file of the given name. clear Clear the entity. delete_by_predicate Recursively delete all child entities that satisfy the predicate. addToGroup Add child entity to a group. addToThis Add child entity."},{"location":"demo/developer/Entity/#type-alias-details","title":"Type Alias Details","text":""},{"location":"demo/developer/Entity/#list_type","title":"list_type","text":"<p>using list_type = std::list&lt;Entity&gt;</p> <p>Child entities are stored in a list, rather than map by name, to preserve declaration order. They may be sorted by name on output.</p>"},{"location":"demo/developer/Entity/#variable-details","title":"Variable Details","text":""},{"location":"demo/developer/Entity/#brief","title":"brief","text":"<p>std::string brief</p> <p>Alternative brief description.</p>"},{"location":"demo/developer/Entity/#concepts","title":"concepts","text":"<p>list_type concepts</p> <p>Child concepts.</p>"},{"location":"demo/developer/Entity/#decl","title":"decl","text":"<p>std::string decl</p> <p>Entity declaration (e.g. function signature). For a file this is its full     contents.</p>"},{"location":"demo/developer/Entity/#dirs","title":"dirs","text":"<p>list_type dirs</p> <p>Child directories.</p>"},{"location":"demo/developer/Entity/#docs","title":"docs","text":"<p>std::string docs</p> <p>Entity documentation.</p>"},{"location":"demo/developer/Entity/#end_line","title":"end_line","text":"<p>uint32_t end_line</p> <p>Ending line in the source file.</p>"},{"location":"demo/developer/Entity/#enums","title":"enums","text":"<p>list_type enums</p> <p>Child enumerators.</p>"},{"location":"demo/developer/Entity/#files","title":"files","text":"<p>list_type files</p> <p>Child files.</p>"},{"location":"demo/developer/Entity/#functions_1","title":"functions","text":"<p>list_type functions</p> <p>Child functions.</p>"},{"location":"demo/developer/Entity/#groups","title":"groups","text":"<p>list_type groups</p> <p>Child groups.</p>"},{"location":"demo/developer/Entity/#hide","title":"hide","text":"<p>bool hide</p> <p>Hide this node?</p>"},{"location":"demo/developer/Entity/#ingroup","title":"ingroup","text":"<p>std::string ingroup</p> <p>Group to which this belongs.</p>"},{"location":"demo/developer/Entity/#line_counts","title":"line_counts","text":"<p>std::vector&lt;int&gt; line_counts</p> <p>For a file only, execution counts for lines. -1 for a line indicates that     it is excluded.</p>"},{"location":"demo/developer/Entity/#lines_covered","title":"lines_covered","text":"<p>int lines_covered</p> <p>Number of lines covered in coverage counts.</p>"},{"location":"demo/developer/Entity/#lines_included","title":"lines_included","text":"<p>int lines_included</p> <p>Number of lines included in coverage counts.</p>"},{"location":"demo/developer/Entity/#macros","title":"macros","text":"<p>list_type macros</p> <p>Child macros.</p>"},{"location":"demo/developer/Entity/#name","title":"name","text":"<p>std::string name</p> <p>Entity name (e.g. name of variable, function, class). For a file or     directory this is the full path.</p>"},{"location":"demo/developer/Entity/#namespaces","title":"namespaces","text":"<p>list_type namespaces</p> <p>Child namespaces.</p>"},{"location":"demo/developer/Entity/#operators","title":"operators","text":"<p>list_type operators</p> <p>Child operators.</p>"},{"location":"demo/developer/Entity/#path","title":"path","text":"<p>std::filesystem::path path</p> <p>Path of source file.</p>"},{"location":"demo/developer/Entity/#start_line","title":"start_line","text":"<p>uint32_t start_line</p> <p>Starting line in the source file.</p>"},{"location":"demo/developer/Entity/#title","title":"title","text":"<p>std::string title</p> <p>Entity title. This is used for the title of the page.</p>"},{"location":"demo/developer/Entity/#type","title":"type","text":"<p>EntityType type</p> <p>Entity type.</p>"},{"location":"demo/developer/Entity/#typedefs","title":"typedefs","text":"<p>list_type typedefs</p> <p>Child typedefs and type aliases.</p>"},{"location":"demo/developer/Entity/#types","title":"types","text":"<p>list_type types</p> <p>Child types.</p>"},{"location":"demo/developer/Entity/#variables_1","title":"variables","text":"<p>list_type variables</p> <p>Child variables.</p>"},{"location":"demo/developer/Entity/#visible","title":"visible","text":"<p>bool visible</p> <p>Is this node visible? This is a computed quantity, that may be overridden     explicitly with <code>hide.</code></p>"},{"location":"demo/developer/Entity/#function-details","title":"Function Details","text":""},{"location":"demo/developer/Entity/#entity_1","title":"Entity","text":"<p>Entity()</p> <p>Constructor.</p>"},{"location":"demo/developer/Entity/#add","title":"add","text":"<p>void add(Entity&amp;&amp; o)</p> <p>Add child entity.</p> <code>o</code> Child entity. <p>If the child has <code>ingroup</code> set, then will search for and add to that group instead.</p>"},{"location":"demo/developer/Entity/#addtogroup","title":"addToGroup","text":"<p>bool addToGroup(Entity&amp;&amp; o)</p> <p>Add child entity to a group.</p> <code>o</code> Child entity with <code>ingroup</code> set. Return True if a group of the given name was found, in which case <code>o</code> will have been added to it, false otherwise."},{"location":"demo/developer/Entity/#addtothis","title":"addToThis","text":"<p>void addToThis(Entity&amp;&amp; o)</p> <p>Add child entity.</p> <code>o</code> Child entity. <p>If the child has <code>ingroup</code> set, it is ignored.</p>"},{"location":"demo/developer/Entity/#clear","title":"clear","text":"<p>void clear()</p> <p>Clear the entity.</p>"},{"location":"demo/developer/Entity/#delete_by_predicate","title":"delete_by_predicate","text":"<p>void delete_by_predicate(std::function&lt;bool(const Entity&amp;)&gt; p)</p> <p>Recursively delete all child entities that satisfy the predicate.</p> <code>p</code> Predicate."},{"location":"demo/developer/Entity/#exists","title":"exists","text":"<p>bool exists(std::filesystem::path&amp; path) const</p> <p>Does a file exist of the given name?</p> <code>path</code> File path."},{"location":"demo/developer/Entity/#get","title":"get","text":"<p>std::list&lt;Entity*&gt; get(std::filesystem::path&amp; path)</p> <p>Get a file of the given name. The file must exist (use <code>exists()</code>).</p> <code>path</code> File path. Return List of entities giving the full path to the file. The last entity represents the file itself, the preceding entities its subdirectories."},{"location":"demo/developer/Entity/#merge","title":"merge","text":"<p>void merge(Entity&amp;&amp; o)</p> <p>Merge the children of another entity into this one.</p> <code>o</code> Other entity."},{"location":"demo/developer/EntityType/","title":"EntityType","text":"<p>enum class EntityType</p> <p>Entity types.</p>"},{"location":"demo/developer/GcovCounter/","title":"GcovCounter","text":"<p>class GcovCounter</p> <p>Gcov processor for coverage data.</p>"},{"location":"demo/developer/GcovCounter/#functions","title":"Functions","text":"Name Description count Read in file and update coverage data."},{"location":"demo/developer/GcovCounter/#function-details","title":"Function Details","text":""},{"location":"demo/developer/GcovCounter/#count","title":"count","text":"<p>void count(const std::filesystem::path&amp; file, Entity&amp; root)</p> <p>Read in file and update coverage data.</p> <code>file</code> Coverage file. <code>root</code> Root entity."},{"location":"demo/developer/JSONCounter/","title":"JSONCounter","text":"<p>class JSONCounter</p> <p>JSON processor for coverage data following gcov/gcovr schema.</p>"},{"location":"demo/developer/JSONCounter/#functions","title":"Functions","text":"Name Description count Read in file and update coverage data."},{"location":"demo/developer/JSONCounter/#function-details","title":"Function Details","text":""},{"location":"demo/developer/JSONCounter/#count","title":"count","text":"<p>void count(const std::filesystem::path&amp; file, Entity&amp; root)</p> <p>Read in file and update coverage data.</p> <code>file</code> Coverage file. <code>root</code> Root entity."},{"location":"demo/developer/JSONGenerator/","title":"JSONGenerator","text":"<p>class JSONGenerator</p> <p>JSON generator for coverage data following gcov/gcovr schema.</p>"},{"location":"demo/developer/JSONGenerator/#functions","title":"Functions","text":"Name Description generate Generate coverage data. generate Generate documentation."},{"location":"demo/developer/JSONGenerator/#function-details","title":"Function Details","text":""},{"location":"demo/developer/JSONGenerator/#generate","title":"generate","text":"<p>void generate(const Entity&amp; root)</p> <p>Generate coverage data.</p> <code>root</code> Root entity. <p>int generate(const Entity&amp; root, int nfiles)</p> <p>Generate documentation.</p> <code>root</code> Root entity. <code>nfiles</code> Number of files output so far. Return Updated number of files output so far."},{"location":"demo/developer/MarkdownGenerator/","title":"MarkdownGenerator","text":"<p>class MarkdownGenerator</p> <p>Markdown generator.</p>"},{"location":"demo/developer/MarkdownGenerator/#variables","title":"Variables","text":"Name Description output Output directory. files Set of files generated during the last call to generate()."},{"location":"demo/developer/MarkdownGenerator/#functions","title":"Functions","text":"Name Description MarkdownGenerator Constructor. generate Generate documentation. clean Clean up after generation, removing files from old runs. generate Recursively generate documentation. coverage Recursively generate coverage. coverage_data Recursively generate coverage table data. coverage_foot Recursively generate coverage table footer. sunburst Produce sunburst chart of code coverage for entity. sunburst_data Produce data for sunburst chart of code coverage for entity. relative Produce a relative path. can_write Can the file be written? frontmatter Produce the YAML frontmatter for an entity. title Produce title for an entity. brief Produce brief description for an entity. line Reduce to a single line. indent Indent lines. stringify Sanitize for a string, escaping double quotes and backslashes. htmlize Sanitize for HTML, replacing special characters with entities. sanitize Sanitize for a file name or internal anchor. color Lookup color for given percentage. icon Lookup icon for given percentage. view Convert a list of entities to a list of pointers to entities, optionally sorting by name."},{"location":"demo/developer/MarkdownGenerator/#variable-details","title":"Variable Details","text":""},{"location":"demo/developer/MarkdownGenerator/#files","title":"files","text":"<p>std::unordered_set&lt;std::filesystem::path&gt; files</p> <p>Set of files generated during the last call to generate().</p>"},{"location":"demo/developer/MarkdownGenerator/#output","title":"output","text":"<p>std::filesystem::path output</p> <p>Output directory.</p>"},{"location":"demo/developer/MarkdownGenerator/#function-details","title":"Function Details","text":""},{"location":"demo/developer/MarkdownGenerator/#markdowngenerator_1","title":"MarkdownGenerator","text":"<p>MarkdownGenerator(const std::filesystem::path&amp; output)</p> <p>Constructor.</p> <code>output</code> Output directory."},{"location":"demo/developer/MarkdownGenerator/#brief","title":"brief","text":"<p>static std::string brief(const Entity&amp; entity)</p> <p>Produce brief description for an entity.</p>"},{"location":"demo/developer/MarkdownGenerator/#can_write","title":"can_write","text":"<p>static bool can_write(const std::filesystem::path&amp; path)</p> <p>Can the file be written? To be overwritten, the file must either not     exist, or exists but has 'generator: doxide' in its YAML frontmatter.</p>"},{"location":"demo/developer/MarkdownGenerator/#clean","title":"clean","text":"<p>void clean()</p> <p>Clean up after generation, removing files from old runs. Traverses the     output directory, removing any Markdown files with 'generator: doxide' in     their YAML frontmatter that were not generated by previous calls of     <code>generate()</code>.</p>"},{"location":"demo/developer/MarkdownGenerator/#color","title":"color","text":"<p>static const std::string&amp; color(const double percent)</p> <p>Lookup color for given percentage.</p>"},{"location":"demo/developer/MarkdownGenerator/#coverage","title":"coverage","text":"<p>void coverage(const std::filesystem::path&amp; output, const Entity&amp; entity)</p> <p>Recursively generate coverage.</p> <code>output</code> Output directory. <code>entity</code> Entity for which to generate coverage."},{"location":"demo/developer/MarkdownGenerator/#coverage_data","title":"coverage_data","text":"<p>static void coverage_data(const Entity&amp; entity, const Entity&amp; root, std::ofstream&amp; out)</p> <p>Recursively generate coverage table data.</p> <code>entity</code> Entity for which to generate coverage. <code>root</code> Root entity for the current page. This is used to determine which are rows should be visible initially. <code>out</code> Output stream."},{"location":"demo/developer/MarkdownGenerator/#coverage_foot","title":"coverage_foot","text":"<p>static void coverage_foot(const Entity&amp; entity, const Entity&amp; root, std::ofstream&amp; out)</p> <p>Recursively generate coverage table footer.</p> <code>entity</code> Entity for which to generate coverage. <code>root</code> Root entity for the current page. This is used to determine which are rows should be visible initially. <code>out</code> Output stream."},{"location":"demo/developer/MarkdownGenerator/#frontmatter","title":"frontmatter","text":"<p>static std::string frontmatter(const Entity&amp; entity)</p> <p>Produce the YAML frontmatter for an entity.</p>"},{"location":"demo/developer/MarkdownGenerator/#generate","title":"generate","text":"<p>void generate(const Entity&amp; root, const bool cov)</p> <p>Generate documentation.</p> <code>root</code> Root entity. <code>cov</code> Include code coverage report? <p>void generate(const std::filesystem::path&amp; output, const Entity&amp; entity, const bool cov)</p> <p>Recursively generate documentation.</p> <code>output</code> Output directory. <code>entity</code> Entity for which to generate documentation. <code>cov</code> Include code coverage report?"},{"location":"demo/developer/MarkdownGenerator/#htmlize","title":"htmlize","text":"<p>static std::string htmlize(const std::string&amp; str)</p> <p>Sanitize for HTML, replacing special characters with entities. Also     replaces some characters that might trigger Markdown formatting.</p>"},{"location":"demo/developer/MarkdownGenerator/#icon","title":"icon","text":"<p>static const std::string&amp; icon(const double percent)</p> <p>Lookup icon for given percentage.</p>"},{"location":"demo/developer/MarkdownGenerator/#indent","title":"indent","text":"<p>static std::string indent(const std::string&amp; str)</p> <p>Indent lines.</p>"},{"location":"demo/developer/MarkdownGenerator/#line","title":"line","text":"<p>static std::string line(const std::string&amp; str)</p> <p>Reduce to a single line.</p>"},{"location":"demo/developer/MarkdownGenerator/#relative","title":"relative","text":"<p>static std::string relative(const std::filesystem::path&amp; path, const std::filesystem::path&amp; base)</p> <p>Produce a relative path.</p>"},{"location":"demo/developer/MarkdownGenerator/#sanitize","title":"sanitize","text":"<p>static std::string sanitize(const std::string&amp; str)</p> <p>Sanitize for a file name or internal anchor.</p>"},{"location":"demo/developer/MarkdownGenerator/#stringify","title":"stringify","text":"<p>static std::string stringify(const std::string&amp; str)</p> <p>Sanitize for a string, escaping double quotes and backslashes.</p>"},{"location":"demo/developer/MarkdownGenerator/#sunburst","title":"sunburst","text":"<p>static void sunburst(const Entity&amp; entity, const Entity&amp; root, std::ofstream&amp; out)</p> <p>Produce sunburst chart of code coverage for entity.</p> <code>entity</code> Entity for which to generate sunburst. <code>root</code> Root entity for the current page. This is used to determine paths relative to the root. <code>out</code> Output stream."},{"location":"demo/developer/MarkdownGenerator/#sunburst_data","title":"sunburst_data","text":"<p>static void sunburst_data(const Entity&amp; entity, const Entity&amp; root, std::ofstream&amp; out)</p> <p>Produce data for sunburst chart of code coverage for entity.</p> <code>entity</code> Entity for which to generate sunburst. <code>root</code> Root entity for the current page. This is used to determine paths relative to the root. <code>out</code> Output stream."},{"location":"demo/developer/MarkdownGenerator/#title","title":"title","text":"<p>static std::string title(const Entity&amp; entity)</p> <p>Produce title for an entity.</p>"},{"location":"demo/developer/MarkdownGenerator/#view","title":"view","text":"<p>static std::list&lt;const Entity*&gt; view(const std::list&lt;Entity&gt;&amp; entities, const bool sort)</p> <p>Convert a list of entities to a list of pointers to entities, optionally     sorting by name.</p> <code>entities</code> List of entities. <code>sort</code> Sort by name?"},{"location":"demo/developer/SourceWatcher/","title":"SourceWatcher","text":"<p>class SourceWatcher</p> <p>Source Watcher.</p> <p>Watches for changes of source files. The files to watch are specified by a glob pattern.</p>"},{"location":"demo/developer/SourceWatcher/#variables","title":"Variables","text":"Name Description patterns The patterns to watch. tracked_files The tracked file paths and their last modification time."},{"location":"demo/developer/SourceWatcher/#functions","title":"Functions","text":"Name Description SourceWatcher Constructor for a list of patterns. SourceWatcher Constructor for a single pattern. changed Check if any of the watched files changed since the last call to <code>changed()</code> or <code>diff()</code>. diff Check if any of the watched files changed since the last call to <code>changed()</code> or <code>diff()</code>. filenames The current source files."},{"location":"demo/developer/SourceWatcher/#variable-details","title":"Variable Details","text":""},{"location":"demo/developer/SourceWatcher/#patterns","title":"patterns","text":"<p>std::list&lt;std::string&gt; patterns</p> <p>The patterns to watch.</p>"},{"location":"demo/developer/SourceWatcher/#tracked_files","title":"tracked_files","text":"<p>std::unordered_map&lt;std::filesystem::path, std::filesystem::file_time_type&gt; tracked_files</p> <p>The tracked file paths and their last modification time.</p>"},{"location":"demo/developer/SourceWatcher/#function-details","title":"Function Details","text":""},{"location":"demo/developer/SourceWatcher/#sourcewatcher_1","title":"SourceWatcher","text":"<p>SourceWatcher(std::list&lt;std::string&gt; patterns)</p> <p>Constructor for a list of patterns.</p> <p> <code>patterns</code> :</p> <p>SourceWatcher(std::string pattern)</p> <p>Constructor for a single pattern.</p>"},{"location":"demo/developer/SourceWatcher/#changed","title":"changed","text":"<p>bool changed()</p> <p>Check if any of the watched files changed since the last call to <code>changed()</code> or <code>diff()</code>.</p>"},{"location":"demo/developer/SourceWatcher/#diff","title":"diff","text":"<p>std::tuple&lt;std::unordered_set&lt;std::filesystem::path&gt;, std::unordered_set&lt;std::filesystem::path&gt;, std::unordered_set&lt;std::filesystem::path&gt;&gt; diff()</p> <p>Check if any of the watched files changed since the last call to <code>changed()</code> or <code>diff()</code>.</p> Return A tuple containing sets of added, modified and deleted file paths."},{"location":"demo/developer/SourceWatcher/#filenames","title":"filenames","text":"<p>std::unordered_set&lt;std::filesystem::path&gt; filenames()</p> <p>The current source files.</p>"},{"location":"demo/developer/YAMLNode/","title":"YAMLNode","text":"<p>class YAMLNode</p> <p>Node in a YAML document.</p>"},{"location":"demo/developer/YAMLNode/#variables","title":"Variables","text":"Name Description contents Contents."},{"location":"demo/developer/YAMLNode/#functions","title":"Functions","text":"Name Description has Does this have a given key? isValue Is this a value? isValue Is there a value at a given path? isSequence Is this a sequence? isSequence Is there a sequence at a given path? isMapping Is this a mapping? isMapping Is there a mapping at a given path? value Get this as a value. value Get this as a value. value Get the value at a given path. value Get the value at a given path. sequence Get this as a sequence. sequence Get this as a sequence. sequence Get the sequence at a given path. sequence Get the sequence at a given path. mapping Get this as a mapping. mapping Get this as a mapping. mapping Get the mapping at a given path. mapping Get the mapping at a given path. set Set the value. setSequence Set as a sequence. setMapping Set as a mapping. push For a sequence, push an uninitialized node onto the end and return it. insert For a mapping, insert a key with an uninitialized value and return the value."},{"location":"demo/developer/YAMLNode/#variable-details","title":"Variable Details","text":""},{"location":"demo/developer/YAMLNode/#contents","title":"contents","text":"<p>variant_type contents</p> <p>Contents.</p>"},{"location":"demo/developer/YAMLNode/#function-details","title":"Function Details","text":""},{"location":"demo/developer/YAMLNode/#has","title":"has","text":"<p>bool has(const key_type&amp; key) const</p> <p>Does this have a given key?</p>"},{"location":"demo/developer/YAMLNode/#insert","title":"insert","text":"<p>YAMLNode&amp; insert(const key_type&amp; key)</p> <p>For a mapping, insert a key with an uninitialized value and return the value.</p>"},{"location":"demo/developer/YAMLNode/#ismapping","title":"isMapping","text":"<p>bool isMapping() const</p> <p>Is this a mapping?</p> <p>template&lt;class... Args&gt; bool isMapping(const key_type&amp; key, Args&amp;&amp;... keys) const</p> <p>Is there a mapping at a given path?</p> <code>key</code> Key. <code>keys...</code> Keys."},{"location":"demo/developer/YAMLNode/#issequence","title":"isSequence","text":"<p>bool isSequence() const</p> <p>Is this a sequence?</p> <p>template&lt;class... Args&gt; bool isSequence(const key_type&amp; key, Args&amp;&amp;... keys) const</p> <p>Is there a sequence at a given path?</p> <code>key</code> Key. <code>keys...</code> Keys."},{"location":"demo/developer/YAMLNode/#isvalue","title":"isValue","text":"<p>bool isValue() const</p> <p>Is this a value?</p> <p>template&lt;class... Args&gt; bool isValue(const key_type&amp; key, Args&amp;&amp;... keys) const</p> <p>Is there a value at a given path?</p> <code>key</code> Key. <code>keys...</code> Keys."},{"location":"demo/developer/YAMLNode/#mapping","title":"mapping","text":"<p>mapping_type&amp; mapping()</p> <p>Get this as a mapping.</p> <p>const mapping_type&amp; mapping() const</p> <p>Get this as a mapping.</p> <p>template&lt;class... Args&gt; mapping_type&amp; mapping(const key_type&amp; key, Args&amp;&amp;... keys)</p> <p>Get the mapping at a given path.</p> <code>key</code> Key. <code>keys...</code> Keys. Return The mapping. <p>template&lt;class... Args&gt; const mapping_type&amp; mapping(const key_type&amp; key, Args&amp;&amp;... keys) const</p> <p>Get the mapping at a given path.</p> <code>key</code> Key. <code>keys...</code> Keys. Return The mapping."},{"location":"demo/developer/YAMLNode/#push","title":"push","text":"<p>YAMLNode&amp; push()</p> <p>For a sequence, push an uninitialized node onto the end and return it.</p>"},{"location":"demo/developer/YAMLNode/#sequence","title":"sequence","text":"<p>sequence_type&amp; sequence()</p> <p>Get this as a sequence.</p> <p>const sequence_type&amp; sequence() const</p> <p>Get this as a sequence.</p> <p>template&lt;class... Args&gt; sequence_type&amp; sequence(const key_type&amp; key, Args&amp;&amp;... keys)</p> <p>Get the sequence at a given path.</p> <code>key</code> Key. <code>keys...</code> Keys. Return The sequence. <p>template&lt;class... Args&gt; const sequence_type&amp; sequence(const key_type&amp; key, Args&amp;&amp;... keys) const</p> <p>Get the sequence at a given path.</p> <code>key</code> Key. <code>keys...</code> Keys. Return The sequence."},{"location":"demo/developer/YAMLNode/#set","title":"set","text":"<p>void set(const variant_type&amp; contents)</p> <p>Set the value.</p>"},{"location":"demo/developer/YAMLNode/#setmapping","title":"setMapping","text":"<p>void setMapping()</p> <p>Set as a mapping.</p>"},{"location":"demo/developer/YAMLNode/#setsequence","title":"setSequence","text":"<p>void setSequence()</p> <p>Set as a sequence.</p>"},{"location":"demo/developer/YAMLNode/#value","title":"value","text":"<p>value_type&amp; value()</p> <p>Get this as a value.</p> <p>const value_type&amp; value() const</p> <p>Get this as a value.</p> <p>template&lt;class... Args&gt; value_type&amp; value(const key_type&amp; key, Args&amp;&amp;... keys)</p> <p>Get the value at a given path.</p> <code>key</code> Key. <code>keys...</code> Keys. Return The value. <p>template&lt;class... Args&gt; const value_type&amp; value(const key_type&amp; key, Args&amp;&amp;... keys) const</p> <p>Get the value at a given path.</p> <code>key</code> Key. <code>keys...</code> Keys. Return The value."},{"location":"demo/developer/YAMLParser/","title":"YAMLParser","text":"<p>class YAMLParser</p> <p>Parser for YAML config files and YAML frontmatter of Markdown files. Also works for JSON, as YAML is nowadays a superset of JSON.</p>"},{"location":"demo/developer/YAMLParser/#variables","title":"Variables","text":"Name Description parser LibYAML parser. event LibYAML event."},{"location":"demo/developer/YAMLParser/#functions","title":"Functions","text":"Name Description YAMLParser Constructor. ~YAMLParser Destructor. parse Parse the file."},{"location":"demo/developer/YAMLParser/#variable-details","title":"Variable Details","text":""},{"location":"demo/developer/YAMLParser/#event","title":"event","text":"<p>yaml_event_t event</p> <p>LibYAML event.</p>"},{"location":"demo/developer/YAMLParser/#parser","title":"parser","text":"<p>yaml_parser_t parser</p> <p>LibYAML parser.</p>"},{"location":"demo/developer/YAMLParser/#function-details","title":"Function Details","text":""},{"location":"demo/developer/YAMLParser/#yamlparser_1","title":"YAMLParser","text":"<p>YAMLParser()</p> <p>Constructor.</p> <code>filename</code> File name."},{"location":"demo/developer/YAMLParser/#parse","title":"parse","text":"<p>YAMLNode parse(const std::filesystem::path&amp; filename)</p> <p>Parse the file.</p> Return The contents of the file."},{"location":"demo/developer/YAMLParser/#yamlparser_2","title":"~YAMLParser","text":"<p>~YAMLParser()</p> <p>Destructor.</p>"},{"location":"demo/ns1/","title":"ns1","text":"<p>Namespace <code>ns1</code>.</p> ns2a Namespace <code>ns1::ns2a</code>. ns2b Namespace <code>ns1::ns2b</code> declared with nested namespace specifier."},{"location":"demo/ns1/ns2a/","title":"ns2a","text":"<p>Namespace <code>ns1::ns2a</code>.</p> ns3 Namespace <code>ns1::ns2a::ns3</code> declared with nested namespace specifier."},{"location":"demo/ns1/ns2a/ns3/","title":"ns3","text":"<p>Namespace <code>ns1::ns2a::ns3</code> declared with nested namespace specifier.</p>"},{"location":"demo/ns1/ns2b/","title":"ns2b","text":"<p>Namespace <code>ns1::ns2b</code> declared with nested namespace specifier.</p>"},{"location":"demo/parsing/","title":"Parsing","text":"<p>Demonstration and test of some parsing capabilities, including basics such as variables, functions, operators and types, and more complex forms such as elaborate templates and SFINAE.</p>"},{"location":"demo/parsing/#types","title":"Types","text":"Name Description Class Test class. ClassTemplate Test class template. ClassTemplateWithMembers Class template with members. ClassWithMembers Class with members. Enum Test enumeration. EnumAfter Test enumeration with values documented after. EnumClass Test scoped enumeration. EnumStruct Test scoped enumeration. ForwardClass Forward class declaration. Struct Test struct. StructTemplate Test struct template. Union Test union. UnionTemplate Test union template."},{"location":"demo/parsing/#type-aliases","title":"Type Aliases","text":"Name Description TypeAlias Test type alias. TypeAliasFunctionPointer Test type alias of function pointer type. TypeAliasTemplate Test type alias template. TypeDef Test typedef. TypeDefFunctionPointer Test typedef of function pointer type."},{"location":"demo/parsing/#concepts","title":"Concepts","text":"Name Description Concept Test concept. TrivialConcept Test trivial concept."},{"location":"demo/parsing/#macros","title":"Macros","text":"Name Description MACRO Test macro. MACRO_AFTER Test macro, documented after entity with <code>///</code> comment MACRO_WITH_ARGS Test macro with arguments. MACRO_WITH_ARGS_AFTER Test macro with arguments, documented after entity with <code>///</code> comment"},{"location":"demo/parsing/#variables","title":"Variables","text":"Name Description a Documented with <code>/** ... */</code> style preceding comment. arr1 Test variable of array type. arr2 Test variable of array type with initializer. b Documented with <code>///</code> style preceding comment. c Documented with <code>///</code> style preceding comment that wraps across multiple lines and has multiple paragraphs. d Documented after entity with <code>///</code> comment e Documentation comment with * and / characters. fp Test variable of function pointer type. ptr1 Test variable of pointer type. ptr2 Test variable of pointer type with initializer. ref1 Test variable of reference type. ref2 Test variable of reference type with initializer. w Test variable. whitespace1 Comment where leading whitespace is important, using <code>/** ... */</code> style preceding comment. whitespace2 Comment where leading whitespace is important, using <code>///</code> style preceding comment. x Test variable with initializer. y Test variable with parenthetical initializer. z Test variable with brace initializer. \u03bb Test variable with unicode character."},{"location":"demo/parsing/#operators","title":"Operators","text":"Name Description operator+ Test operator. operator+ Test operator template. operator+ Test operator template with SFINAE. operator+ Test inline operator. operator+ Test inline operator template. operator+ Test inline operator template with SFINAE."},{"location":"demo/parsing/#functions","title":"Functions","text":"Name Description f Test function. f Test function that returns a reference. f Test function that returns a pointer. f Test function that returns a function pointer. f Test function template. f Test function template with SFINAE. f Test inline function. f Test inline function template. f Test inline function template with SFINAE."},{"location":"demo/parsing/#type-alias-details","title":"Type Alias Details","text":""},{"location":"demo/parsing/#typealias","title":"TypeAlias","text":"<p>using TypeAlias = int</p> <p>Test type alias.</p>"},{"location":"demo/parsing/#typealiasfunctionpointer","title":"TypeAliasFunctionPointer","text":"<p>using TypeAliasFunctionPointer = int (*)(int, int)</p> <p>Test type alias of function pointer type.</p>"},{"location":"demo/parsing/#typealiastemplate","title":"TypeAliasTemplate","text":"<p>template&lt;class T&gt; using TypeAliasTemplate = int</p> <p>Test type alias template.</p>"},{"location":"demo/parsing/#typedef","title":"TypeDef","text":"<p>typedef int TypeDef</p> <p>Test typedef.</p>"},{"location":"demo/parsing/#typedeffunctionpointer","title":"TypeDefFunctionPointer","text":"<p>typedef int (*TypeDefFunctionPointer)(int, int)</p> <p>Test typedef of function pointer type.</p>"},{"location":"demo/parsing/#concept-details","title":"Concept Details","text":""},{"location":"demo/parsing/#concept","title":"Concept","text":"<p>template&lt;class T&gt; concept Concept = std::is_arithmetic_v&lt;T&gt;</p> <p>Test concept.</p>"},{"location":"demo/parsing/#trivialconcept","title":"TrivialConcept","text":"<p>template&lt;class T&gt; concept TrivialConcept = true</p> <p>Test trivial concept.</p>"},{"location":"demo/parsing/#macro-details","title":"Macro Details","text":""},{"location":"demo/parsing/#macro","title":"MACRO","text":"<p>#define MACRO</p> <p>Test macro.</p>"},{"location":"demo/parsing/#macro_after","title":"MACRO_AFTER","text":"<p>#define MACRO_AFTER</p> <p>Test macro, documented after entity with <code>///</code> comment</p>"},{"location":"demo/parsing/#macro_with_args","title":"MACRO_WITH_ARGS","text":"<p>#define MACRO_WITH_ARGS(x, y)</p> <p>Test macro with arguments.</p>"},{"location":"demo/parsing/#macro_with_args_after","title":"MACRO_WITH_ARGS_AFTER","text":"<p>#define MACRO_WITH_ARGS_AFTER(x, y)</p> <p>Test macro with arguments, documented after entity with <code>///</code> comment</p>"},{"location":"demo/parsing/#variable-details","title":"Variable Details","text":""},{"location":"demo/parsing/#a","title":"a","text":"<p>int a</p> <p>Documented with <code>/** ... */</code> style preceding comment.</p>"},{"location":"demo/parsing/#arr1","title":"arr1","text":"<p>int arr1[10]</p> <p>Test variable of array type.</p>"},{"location":"demo/parsing/#arr2","title":"arr2","text":"<p>int arr2[10]</p> <p>Test variable of array type with initializer.</p>"},{"location":"demo/parsing/#b","title":"b","text":"<p>int b</p> <p>Documented with <code>///</code> style preceding comment.</p>"},{"location":"demo/parsing/#c","title":"c","text":"<p>int c</p> <p>Documented with <code>///</code> style preceding comment that wraps across multiple lines and has multiple paragraphs.</p> <p>This is the second paragraph.</p> <p>This is the third paragraph.</p>"},{"location":"demo/parsing/#d","title":"d","text":"<p>int d</p> <p>Documented after entity with <code>///</code> comment</p>"},{"location":"demo/parsing/#e","title":"e","text":"<p>int e</p> <p>Documentation comment with * and / characters.</p>"},{"location":"demo/parsing/#fp","title":"fp","text":"<p>int (*fp)(int, int)</p> <p>Test variable of function pointer type.</p>"},{"location":"demo/parsing/#ptr1","title":"ptr1","text":"<p>int* ptr1</p> <p>Test variable of pointer type.</p>"},{"location":"demo/parsing/#ptr2","title":"ptr2","text":"<p>int* ptr2</p> <p>Test variable of pointer type with initializer.</p>"},{"location":"demo/parsing/#ref1","title":"ref1","text":"<p>int&amp; ref1</p> <p>Test variable of reference type.</p>"},{"location":"demo/parsing/#ref2","title":"ref2","text":"<p>int&amp; ref2</p> <p>Test variable of reference type with initializer.</p>"},{"location":"demo/parsing/#w","title":"w","text":"<p>int w</p> <p>Test variable.</p>"},{"location":"demo/parsing/#whitespace1","title":"whitespace1","text":"<p>int whitespace1</p> <p>Comment where leading whitespace is important, using <code>/** ... */</code> style preceding comment. Details should show code if indenting is correctly preserved.</p> <pre><code>int main();\n</code></pre>"},{"location":"demo/parsing/#whitespace2","title":"whitespace2","text":"<p>int whitespace2</p> <p>Comment where leading whitespace is important, using <code>///</code> style preceding comment. Details should show code if indenting is correctly preserved.</p> <pre><code>int main();\n</code></pre>"},{"location":"demo/parsing/#x","title":"x","text":"<p>int x</p> <p>Test variable with initializer.</p>"},{"location":"demo/parsing/#y","title":"y","text":"<p>int y</p> <p>Test variable with parenthetical initializer.</p>"},{"location":"demo/parsing/#z","title":"z","text":"<p>int z</p> <p>Test variable with brace initializer.</p>"},{"location":"demo/parsing/#_1","title":"\u03bb","text":"<p>int \u03bb</p> <p>Test variable with unicode character.</p>"},{"location":"demo/parsing/#operator-details","title":"Operator Details","text":""},{"location":"demo/parsing/#operator","title":"operator+","text":"<p>int operator+(int x, int y)</p> <p>Test operator.</p> <p>template&lt;class T&gt; T operator+(T x, T y)</p> <p>Test operator template.</p> <p>template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt; T operator+(T x, T y)</p> <p>Test operator template with SFINAE.</p> <p>inline int operator+(int x, int y)</p> <p>Test inline operator.</p> <p>template&lt;class T&gt; T operator+(T x, T y)</p> <p>Test inline operator template.</p> <p>template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt; T operator+(T x, T y)</p> <p>Test inline operator template with SFINAE.</p>"},{"location":"demo/parsing/#function-details","title":"Function Details","text":""},{"location":"demo/parsing/#f","title":"f","text":"<p>int f(int x, int y)</p> <p>Test function.</p> <p>int&amp; f(int x, int y)</p> <p>Test function that returns a reference.</p> <p>int* f(int x, int y)</p> <p>Test function that returns a pointer.</p> <p>int (*f(int x, int y))(int, int)</p> <p>Test function that returns a function pointer.</p> <p>template&lt;class T&gt; T f(T x, T y)</p> <p>Test function template.</p> <p>template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt; T f(T x, T y)</p> <p>Test function template with SFINAE.</p> <p>inline int f(int x, int y)</p> <p>Test inline function.</p> <p>template&lt;class T&gt; T f(T x, T y)</p> <p>Test inline function template.</p> <p>template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt; T f(T x, T y)</p> <p>Test inline function template with SFINAE.</p>"},{"location":"demo/parsing/Class/","title":"Class","text":"<p>class Class</p> <p>Test class.</p>"},{"location":"demo/parsing/ClassTemplate/","title":"ClassTemplate","text":"<p>template&lt;class T&gt; class ClassTemplate</p> <p>Test class template.</p>"},{"location":"demo/parsing/ClassTemplateWithMembers/","title":"ClassTemplateWithMembers","text":"<p>template&lt;class T&gt; class ClassTemplateWithMembers</p> <p>Class template with members.</p>"},{"location":"demo/parsing/ClassTemplateWithMembers/#variables","title":"Variables","text":"Name Description w Test member variable."},{"location":"demo/parsing/ClassTemplateWithMembers/#variable-details","title":"Variable Details","text":""},{"location":"demo/parsing/ClassTemplateWithMembers/#w","title":"w","text":"<p>int w</p> <p>Test member variable.</p>"},{"location":"demo/parsing/ClassWithMembers/","title":"ClassWithMembers","text":"<p>class ClassWithMembers</p> <p>Class with members.</p>"},{"location":"demo/parsing/ClassWithMembers/#types","title":"Types","text":"Name Description InnerClass Inner class. InnerEnum Inner enumeration."},{"location":"demo/parsing/ClassWithMembers/#type-aliases","title":"Type Aliases","text":"Name Description InnerTypeDef Inner typedef. InnerTypeAlias Inner type alias."},{"location":"demo/parsing/ClassWithMembers/#variables","title":"Variables","text":"Name Description x Test member variable. y Test member variable with initializer. z Test member variable with brace initializer. arr1 Test member variable of array type. ref1 Test member variable of reference type. ptr1 Test member variable of pointer type. arr2 Test member variable of array type with initializer. ref2 Test member variable of reference type with initializer. ptr2 Test member variable of pointer type with initializer. \u03bb Test member variable with unicode character. fp Test member variable of function pointer type. escapee Attempt to move a member out of its class with <code>@ingroup</code>, but should remain in <code>ClassWithMembers</code>."},{"location":"demo/parsing/ClassWithMembers/#operators","title":"Operators","text":"Name Description operator+ Test member operator. operator+ Test member operator template. operator+ Test member function template with SFINAE. operator+ Test inline member operator. operator+ Test inline member operator template. operator+ Test inline member operator template with SFINAE. operator= Test assignment operator. int Test conversion operator declaration. int Test reference conversion operator declaration. int Test pointer conversion operator declaration. double Test conversion operator definition."},{"location":"demo/parsing/ClassWithMembers/#functions","title":"Functions","text":"Name Description ClassWithMembers Test constructor. ~ClassWithMembers Test destructor. f Test member function. f Test member function that returns a reference. f Test member function that returns a pointer. f Test member function that returns a function pointer. f Test member function template. f Test member function template with SFINAE. f Test inline member function. f Test inline member function template. f Test inline member function template with SFINAE."},{"location":"demo/parsing/ClassWithMembers/#type-alias-details","title":"Type Alias Details","text":""},{"location":"demo/parsing/ClassWithMembers/#innertypealias","title":"InnerTypeAlias","text":"<p>using InnerTypeAlias = int</p> <p>Inner type alias.</p>"},{"location":"demo/parsing/ClassWithMembers/#innertypedef","title":"InnerTypeDef","text":"<p>typedef int InnerTypeDef</p> <p>Inner typedef.</p>"},{"location":"demo/parsing/ClassWithMembers/#variable-details","title":"Variable Details","text":""},{"location":"demo/parsing/ClassWithMembers/#arr1","title":"arr1","text":"<p>int arr1[10]</p> <p>Test member variable of array type.</p>"},{"location":"demo/parsing/ClassWithMembers/#arr2","title":"arr2","text":"<p>int arr2[10]</p> <p>Test member variable of array type with initializer.</p>"},{"location":"demo/parsing/ClassWithMembers/#escapee","title":"escapee","text":"<p>int escapee</p> <p>Attempt to move a member out of its class with <code>@ingroup</code>, but should remain in <code>ClassWithMembers</code>.</p>"},{"location":"demo/parsing/ClassWithMembers/#fp","title":"fp","text":"<p>int (*fp)(int, int)</p> <p>Test member variable of function pointer type.</p>"},{"location":"demo/parsing/ClassWithMembers/#ptr1","title":"ptr1","text":"<p>int* ptr1</p> <p>Test member variable of pointer type.</p>"},{"location":"demo/parsing/ClassWithMembers/#ptr2","title":"ptr2","text":"<p>int* ptr2</p> <p>Test member variable of pointer type with initializer.</p>"},{"location":"demo/parsing/ClassWithMembers/#ref1","title":"ref1","text":"<p>int&amp; ref1</p> <p>Test member variable of reference type.</p>"},{"location":"demo/parsing/ClassWithMembers/#ref2","title":"ref2","text":"<p>int&amp; ref2</p> <p>Test member variable of reference type with initializer.</p>"},{"location":"demo/parsing/ClassWithMembers/#x","title":"x","text":"<p>int x</p> <p>Test member variable.</p>"},{"location":"demo/parsing/ClassWithMembers/#y","title":"y","text":"<p>int y</p> <p>Test member variable with initializer.</p>"},{"location":"demo/parsing/ClassWithMembers/#z","title":"z","text":"<p>int z</p> <p>Test member variable with brace initializer.</p>"},{"location":"demo/parsing/ClassWithMembers/#_1","title":"\u03bb","text":"<p>int \u03bb</p> <p>Test member variable with unicode character.</p>"},{"location":"demo/parsing/ClassWithMembers/#operator-details","title":"Operator Details","text":""},{"location":"demo/parsing/ClassWithMembers/#double","title":"double","text":"<p>operator double() const</p> <p>Test conversion operator definition.</p>"},{"location":"demo/parsing/ClassWithMembers/#int","title":"int","text":"<p>operator int() const</p> <p>Test conversion operator declaration.</p> <p>operator int&amp;() const</p> <p>Test reference conversion operator declaration.</p> <p>operator int*() const</p> <p>Test pointer conversion operator declaration.</p>"},{"location":"demo/parsing/ClassWithMembers/#operator","title":"operator+","text":"<p>int operator+(int x, int y)</p> <p>Test member operator.</p> <p>template&lt;class T&gt; T operator+(T x, T y)</p> <p>Test member operator template.</p> <p>template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt; T operator+(T x, T y)</p> <p>Test member function template with SFINAE.</p> <p>inline int operator+(int x, int y)</p> <p>Test inline member operator.</p> <p>template&lt;class T&gt; T operator+(T x, T y)</p> <p>Test inline member operator template.</p> <p>template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt; T operator+(T x, T y)</p> <p>Test inline member operator template with SFINAE.</p>"},{"location":"demo/parsing/ClassWithMembers/#operator_1","title":"operator=","text":"<p>ClassWithMembers&amp; operator=(const ClassWithMembers&amp; o)</p> <p>Test assignment operator.</p>"},{"location":"demo/parsing/ClassWithMembers/#function-details","title":"Function Details","text":""},{"location":"demo/parsing/ClassWithMembers/#classwithmembers_1","title":"ClassWithMembers","text":"<p>ClassWithMembers()</p> <p>Test constructor.</p>"},{"location":"demo/parsing/ClassWithMembers/#f","title":"f","text":"<p>int f(int x, int y)</p> <p>Test member function.</p> <p>int&amp; f(int x, int y)</p> <p>Test member function that returns a reference.</p> <p>int* f(int x, int y)</p> <p>Test member function that returns a pointer.</p> <p>int (*f(int x, int y))(int, int)</p> <p>Test member function that returns a function pointer.</p> <p>template&lt;class T&gt; T f(T x, T y)</p> <p>Test member function template.</p> <p>template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt; T f(T x, T y)</p> <p>Test member function template with SFINAE.</p> <p>inline int f(int x, int y)</p> <p>Test inline member function.</p> <p>template&lt;class T&gt; T f(T x, T y)</p> <p>Test inline member function template.</p> <p>template&lt;class T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt; T f(T x, T y)</p> <p>Test inline member function template with SFINAE.</p>"},{"location":"demo/parsing/ClassWithMembers/#classwithmembers_2","title":"~ClassWithMembers","text":"<p>~ClassWithMembers()</p> <p>Test destructor.</p>"},{"location":"demo/parsing/Enum/","title":"Enum","text":"<p>enum Enum</p> <p>Test enumeration.</p> FIRST First possibility. SECOND Second possibility. THIRD Third possibility."},{"location":"demo/parsing/EnumAfter/","title":"EnumAfter","text":"<p>enum EnumAfter</p> <p>Test enumeration with values documented after.</p> FIRST First possibility, document after with <code>///</code> comment SECOND Second possibility, document after with <code>///</code> comment THIRD Third possibility, document after with <code>///</code> comment"},{"location":"demo/parsing/EnumClass/","title":"EnumClass","text":"<p>enum class EnumClass</p> <p>Test scoped enumeration.</p> FIRST First possibility. SECOND Second possibility. THIRD Third possibility."},{"location":"demo/parsing/EnumStruct/","title":"EnumStruct","text":"<p>enum struct EnumStruct</p> <p>Test scoped enumeration.</p> FIRST First possibility. SECOND Second possibility. THIRD Third possibility."},{"location":"demo/parsing/ForwardClass/","title":"ForwardClass","text":"<p>class ForwardClass</p> <p>Forward class declaration.</p>"},{"location":"demo/parsing/Struct/","title":"Struct","text":"<p>struct Struct</p> <p>Test struct.</p>"},{"location":"demo/parsing/StructTemplate/","title":"StructTemplate","text":"<p>template&lt;class T&gt; struct StructTemplate</p> <p>Test struct template.</p>"},{"location":"demo/parsing/Union/","title":"Union","text":"<p>union Union</p> <p>Test union.</p>"},{"location":"demo/parsing/UnionTemplate/","title":"UnionTemplate","text":"<p>template&lt;class T&gt; union UnionTemplate</p> <p>Test union template.</p>"},{"location":"demo/parsing/ClassWithMembers/InnerClass/","title":"InnerClass","text":"<p>class InnerClass</p> <p>Inner class.</p>"},{"location":"demo/parsing/ClassWithMembers/InnerClass/#variables","title":"Variables","text":"Name Description w Test member variable of inner class."},{"location":"demo/parsing/ClassWithMembers/InnerClass/#variable-details","title":"Variable Details","text":""},{"location":"demo/parsing/ClassWithMembers/InnerClass/#w","title":"w","text":"<p>int w</p> <p>Test member variable of inner class.</p>"},{"location":"demo/parsing/ClassWithMembers/InnerEnum/","title":"InnerEnum","text":"<p>enum InnerEnum</p> <p>Inner enumeration.</p> FIRST First possibility. SECOND Second possibility. THIRD Third possibility."},{"location":"demo/presentation/","title":"Presentation","text":"<p>Demonstration and test of Markdown elements, such as code, syntax highlighting, tables, images, and admonitions.</p>"},{"location":"demo/presentation/#functions","title":"Functions","text":"Name Description f Function with documentation demonstrating various presentation features. g Function with documentation demonstrating various presentation features, this time using end-of-line comments. h Function demonstrating all possible annotations. i Function demonstrating all possible annotations, this time using end-of-line comments."},{"location":"demo/presentation/#function-details","title":"Function Details","text":""},{"location":"demo/presentation/#f","title":"f","text":"<p>int f(int x, int y)</p> <p>Function with documentation demonstrating various presentation features.</p>"},{"location":"demo/presentation/#lists","title":"Lists","text":"<p>Itemized list:</p> <ul> <li>Itemized list item.</li> <li>Itemized list item.<ul> <li>Nested itemized list item.</li> </ul> </li> <li>Itemized list item.</li> </ul> <p>Numbered list:</p> <ol> <li>Enumerated list item.</li> <li>Enumerated list item.<ul> <li>Nested itemized list item.</li> </ul> </li> <li>Enumerated list item.</li> </ol>"},{"location":"demo/presentation/#tables","title":"Tables","text":"Column 1 Column 2 Column 3 Row 1, Column 1 Row 1, Column 2 Row 1, Column 3 Row 2, Column 1 Row 2, Column 2 Row 2, Column 3 Row 3, Column 1 Row 3, Column 2 Row 3, Column 3"},{"location":"demo/presentation/#code","title":"Code","text":"<pre><code>void f(int x, int y);\n</code></pre> <pre><code>/* nested comment in code */\nvoid f(int x, int y);\n</code></pre>"},{"location":"demo/presentation/#images","title":"Images","text":""},{"location":"demo/presentation/#headings","title":"Headings","text":""},{"location":"demo/presentation/#heading-5","title":"Heading 5","text":""},{"location":"demo/presentation/#heading-6","title":"Heading 6","text":""},{"location":"demo/presentation/#admonitions","title":"Admonitions","text":"<p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Abstract</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Info</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Tip</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Success</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Question</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Warning</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Failure</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Danger</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Bug</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Example</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Quote</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>"},{"location":"demo/presentation/#g","title":"g","text":"<p>int g(int x, int y)</p> <pre><code>Function with documentation demonstrating various presentation features,\nthis time using end-of-line comments.\n</code></pre>"},{"location":"demo/presentation/#lists_1","title":"Lists","text":"<p>Itemized list:</p> <ul> <li>Itemized list item.</li> <li>Itemized list item.</li> <li>Itemized list item.</li> </ul> <p>Numbered list:</p> <ol> <li>Enumerated list item.</li> <li>Enumerated list item.</li> <li>Enumerated list item.</li> </ol>"},{"location":"demo/presentation/#tables_1","title":"Tables","text":"Column 1 Column 2 Column 3 Row 1, Column 1 Row 1, Column 2 Row 1, Column 3 Row 2, Column 1 Row 2, Column 2 Row 2, Column 3 Row 3, Column 1 Row 3, Column 2 Row 3, Column 3"},{"location":"demo/presentation/#code_1","title":"Code","text":"<pre><code>void f(int x, int y);\n</code></pre> <pre><code>/// nested comment in code\nvoid f(int x, int y);\n</code></pre>"},{"location":"demo/presentation/#images_1","title":"Images","text":""},{"location":"demo/presentation/#headings_1","title":"Headings","text":""},{"location":"demo/presentation/#heading-5_1","title":"Heading 5","text":""},{"location":"demo/presentation/#heading-6_1","title":"Heading 6","text":""},{"location":"demo/presentation/#admonitions_1","title":"Admonitions","text":"<p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Abstract</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Info</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Tip</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Success</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Question</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Warning</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Failure</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Danger</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Bug</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Example</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p> <p>Quote</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>"},{"location":"demo/presentation/#h","title":"h","text":"<p>template&lt;class T&gt; int h(int x, int y, int&amp; z, int&amp; w)</p> <p>Function demonstrating all possible annotations.</p> <code>T</code> Template parameter. <code>x</code> Input parameter. <code>y</code> Input parameter. <code>z</code> Output parameter. <code>w</code> Input-output parameter. <code>u</code> Input parameter with a description that spans across multiple lines. Return Return value. Pre-condition Pre-condition. Post-condition Post-condition. Throw Exception. See f"},{"location":"demo/presentation/#i","title":"i","text":"<p>template&lt;class T&gt; int i(int x, int y, int&amp; z, int&amp; w)</p> <p>Function demonstrating all possible annotations, this time using end-of-line comments.</p> <code>T</code> Template parameter. <code>x</code> Input parameter. <code>y</code> Input parameter. <code>z</code> Output parameter. <code>w</code> Input-output parameter. <code>u</code> Input parameter with a description that spans across multiple lines. Return Return value. Pre-condition Pre-condition. Post-condition Post-condition. Throw Exception. See f"}]}